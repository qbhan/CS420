Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COLON
    DOUBLEQUOTE
    ELSE_IF
    PERIOD
    POINTER
    QUOTE

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration_list
Rule 2     declaration_list -> declaration_list func_declaration
Rule 3     declaration_list -> declaration_list declaration
Rule 4     declaration_list -> empty
Rule 5     func_declaration -> type ID LPAREN params RPAREN stmt_block
Rule 6     func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block
Rule 7     func_declaration -> type MAIN LPAREN params RPAREN stmt_block
Rule 8     params -> VOID
Rule 9     params -> param_list
Rule 10    param_list -> param
Rule 11    param_list -> param_list COMMA param
Rule 12    param -> type ID
Rule 13    param -> type TIMES ID
Rule 14    genstmt -> mstmt
Rule 15    genstmt -> umstmt
Rule 16    mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt
Rule 17    mstmt -> stmt
Rule 18    umstmt -> IF LPAREN expr RPAREN genstmt
Rule 19    umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt
Rule 20    stmt -> expr SEMICOLON
Rule 21    stmt -> declaration SEMICOLON
Rule 22    stmt -> stmt_block
Rule 23    stmt -> stmt_forloop
Rule 24    stmt -> stmt_return
Rule 25    stmt -> SEMICOLON
Rule 26    stmt -> expr error
Rule 27    stmt -> PRINT LPAREN argument_list RPAREN
Rule 28    declaration -> type id_list
Rule 29    declaration -> type TIMES id_list
Rule 30    id_list -> idbracket
Rule 31    id_list -> id_list COMMA idbracket
Rule 32    idbracket -> ID
Rule 33    idbracket -> ID LBRACKET INUM RBRACKET
Rule 34    type -> INT
Rule 35    type -> FLOAT
Rule 36    type -> VOID
Rule 37    stmt_block -> LBRACE stmt_list RBRACE
Rule 38    stmt_list -> stmt_list genstmt
Rule 39    stmt_list -> empty
Rule 40    stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
Rule 41    stmt_return -> RETURN expr SEMICOLON
Rule 42    stmt_return -> RETURN SEMICOLON
Rule 43    expr -> ID EQUAL expr
Rule 44    expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr
Rule 45    expr -> TIMES ID EQUAL expr
Rule 46    expr -> incr_expr
Rule 47    expr -> basic_expr
Rule 48    basic_expr -> basic_expr compare arith_expr
Rule 49    basic_expr -> arith_expr
Rule 50    compare -> EQ
Rule 51    compare -> NEQ
Rule 52    compare -> GT
Rule 53    compare -> LT
Rule 54    incr_expr -> ID INCREMENT
Rule 55    incr_expr -> INCREMENT ID
Rule 56    arith_expr -> MINUS arith_expr
Rule 57    arith_expr -> LPAREN arith_expr RPAREN
Rule 58    arith_expr -> LPAREN error
Rule 59    arith_expr -> arith_expr PLUS arith_expr
Rule 60    arith_expr -> arith_expr MINUS arith_expr
Rule 61    arith_expr -> arith_expr TIMES arith_expr
Rule 62    arith_expr -> arith_expr DIV arith_expr
Rule 63    arith_expr -> ID
Rule 64    arith_expr -> FNUM
Rule 65    arith_expr -> INUM
Rule 66    arith_expr -> TIMES ID
Rule 67    arith_expr -> ADDRESS ID
Rule 68    arith_expr -> ID LBRACKET arith_expr RBRACKET
Rule 69    arith_expr -> ID LPAREN argument_list RPAREN
Rule 70    arith_expr -> ID LPAREN argument_list error
Rule 71    argument_list -> argument
Rule 72    argument_list -> argument_list COMMA argument
Rule 73    argument -> empty
Rule 74    argument -> arith_expr
Rule 75    argument -> LITERAL
Rule 76    argument -> error
Rule 77    empty -> <empty>

Terminals, with rules where they appear

ADDRESS              : 67
COLON                : 
COMMA                : 11 31 72
DIV                  : 62
DOUBLEQUOTE          : 
ELSE                 : 16 19
ELSE_IF              : 
EQ                   : 50
EQUAL                : 43 44 45
FLOAT                : 35
FNUM                 : 64
FOR                  : 40
GT                   : 52
ID                   : 5 6 12 13 32 33 43 44 45 54 55 63 66 67 68 69 70
IF                   : 16 18 19
INCREMENT            : 54 55
INT                  : 34
INUM                 : 33 65
LBRACE               : 37
LBRACKET             : 33 44 68
LITERAL              : 75
LPAREN               : 5 6 7 16 18 19 27 40 57 58 69 70
LT                   : 53
MAIN                 : 7
MINUS                : 56 60
NEQ                  : 51
PERIOD               : 
PLUS                 : 59
POINTER              : 
PRINT                : 27
QUOTE                : 
RBRACE               : 37
RBRACKET             : 33 44 68
RETURN               : 41 42
RPAREN               : 5 6 7 16 18 19 27 40 57 69
SEMICOLON            : 20 21 25 40 40 41 42
TIMES                : 6 13 29 45 61 66
VOID                 : 8 36
error                : 26 58 70 76

Nonterminals, with rules where they appear

argument             : 71 72
argument_list        : 27 69 70 72
arith_expr           : 44 48 49 56 57 59 59 60 60 61 61 62 62 68 74
basic_expr           : 47 48
compare              : 48
declaration          : 3 21
declaration_list     : 1 2 3
empty                : 4 39 73
expr                 : 16 18 19 20 26 40 40 40 41 43 44 45
func_declaration     : 2
genstmt              : 18 38
id_list              : 28 29 31
idbracket            : 30 31
incr_expr            : 46
mstmt                : 14 16 16 19
param                : 10 11
param_list           : 9 11
params               : 5 6 7
program              : 0
stmt                 : 17 40
stmt_block           : 5 6 7 22
stmt_forloop         : 23
stmt_list            : 37 38
stmt_return          : 24
type                 : 5 6 7 12 13 28 29
umstmt               : 15 19

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration_list
    (2) declaration_list -> . declaration_list func_declaration
    (3) declaration_list -> . declaration_list declaration
    (4) declaration_list -> . empty
    (77) empty -> .

    INT             reduce using rule 77 (empty -> .)
    FLOAT           reduce using rule 77 (empty -> .)
    VOID            reduce using rule 77 (empty -> .)
    $end            reduce using rule 77 (empty -> .)

    program                        shift and go to state 1
    declaration_list               shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> declaration_list .
    (2) declaration_list -> declaration_list . func_declaration
    (3) declaration_list -> declaration_list . declaration
    (5) func_declaration -> . type ID LPAREN params RPAREN stmt_block
    (6) func_declaration -> . type TIMES ID LPAREN params RPAREN stmt_block
    (7) func_declaration -> . type MAIN LPAREN params RPAREN stmt_block
    (28) declaration -> . type id_list
    (29) declaration -> . type TIMES id_list
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . VOID

    $end            reduce using rule 1 (program -> declaration_list .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9

    func_declaration               shift and go to state 4
    declaration                    shift and go to state 5
    type                           shift and go to state 6

state 3

    (4) declaration_list -> empty .

    INT             reduce using rule 4 (declaration_list -> empty .)
    FLOAT           reduce using rule 4 (declaration_list -> empty .)
    VOID            reduce using rule 4 (declaration_list -> empty .)
    $end            reduce using rule 4 (declaration_list -> empty .)


state 4

    (2) declaration_list -> declaration_list func_declaration .

    INT             reduce using rule 2 (declaration_list -> declaration_list func_declaration .)
    FLOAT           reduce using rule 2 (declaration_list -> declaration_list func_declaration .)
    VOID            reduce using rule 2 (declaration_list -> declaration_list func_declaration .)
    $end            reduce using rule 2 (declaration_list -> declaration_list func_declaration .)


state 5

    (3) declaration_list -> declaration_list declaration .

    INT             reduce using rule 3 (declaration_list -> declaration_list declaration .)
    FLOAT           reduce using rule 3 (declaration_list -> declaration_list declaration .)
    VOID            reduce using rule 3 (declaration_list -> declaration_list declaration .)
    $end            reduce using rule 3 (declaration_list -> declaration_list declaration .)


state 6

    (5) func_declaration -> type . ID LPAREN params RPAREN stmt_block
    (6) func_declaration -> type . TIMES ID LPAREN params RPAREN stmt_block
    (7) func_declaration -> type . MAIN LPAREN params RPAREN stmt_block
    (28) declaration -> type . id_list
    (29) declaration -> type . TIMES id_list
    (30) id_list -> . idbracket
    (31) id_list -> . id_list COMMA idbracket
    (32) idbracket -> . ID
    (33) idbracket -> . ID LBRACKET INUM RBRACKET

    ID              shift and go to state 10
    TIMES           shift and go to state 11
    MAIN            shift and go to state 12

    id_list                        shift and go to state 13
    idbracket                      shift and go to state 14

state 7

    (34) type -> INT .

    ID              reduce using rule 34 (type -> INT .)
    TIMES           reduce using rule 34 (type -> INT .)
    MAIN            reduce using rule 34 (type -> INT .)


state 8

    (35) type -> FLOAT .

    ID              reduce using rule 35 (type -> FLOAT .)
    TIMES           reduce using rule 35 (type -> FLOAT .)
    MAIN            reduce using rule 35 (type -> FLOAT .)


state 9

    (36) type -> VOID .

    ID              reduce using rule 36 (type -> VOID .)
    TIMES           reduce using rule 36 (type -> VOID .)
    MAIN            reduce using rule 36 (type -> VOID .)


state 10

    (5) func_declaration -> type ID . LPAREN params RPAREN stmt_block
    (32) idbracket -> ID .
    (33) idbracket -> ID . LBRACKET INUM RBRACKET

    LPAREN          shift and go to state 15
    COMMA           reduce using rule 32 (idbracket -> ID .)
    INT             reduce using rule 32 (idbracket -> ID .)
    FLOAT           reduce using rule 32 (idbracket -> ID .)
    VOID            reduce using rule 32 (idbracket -> ID .)
    $end            reduce using rule 32 (idbracket -> ID .)
    LBRACKET        shift and go to state 16


state 11

    (6) func_declaration -> type TIMES . ID LPAREN params RPAREN stmt_block
    (29) declaration -> type TIMES . id_list
    (30) id_list -> . idbracket
    (31) id_list -> . id_list COMMA idbracket
    (32) idbracket -> . ID
    (33) idbracket -> . ID LBRACKET INUM RBRACKET

    ID              shift and go to state 17

    id_list                        shift and go to state 18
    idbracket                      shift and go to state 14

state 12

    (7) func_declaration -> type MAIN . LPAREN params RPAREN stmt_block

    LPAREN          shift and go to state 19


state 13

    (28) declaration -> type id_list .
    (31) id_list -> id_list . COMMA idbracket

    INT             reduce using rule 28 (declaration -> type id_list .)
    FLOAT           reduce using rule 28 (declaration -> type id_list .)
    VOID            reduce using rule 28 (declaration -> type id_list .)
    $end            reduce using rule 28 (declaration -> type id_list .)
    SEMICOLON       reduce using rule 28 (declaration -> type id_list .)
    COMMA           shift and go to state 20


state 14

    (30) id_list -> idbracket .

    COMMA           reduce using rule 30 (id_list -> idbracket .)
    INT             reduce using rule 30 (id_list -> idbracket .)
    FLOAT           reduce using rule 30 (id_list -> idbracket .)
    VOID            reduce using rule 30 (id_list -> idbracket .)
    $end            reduce using rule 30 (id_list -> idbracket .)
    SEMICOLON       reduce using rule 30 (id_list -> idbracket .)


state 15

    (5) func_declaration -> type ID LPAREN . params RPAREN stmt_block
    (8) params -> . VOID
    (9) params -> . param_list
    (10) param_list -> . param
    (11) param_list -> . param_list COMMA param
    (12) param -> . type ID
    (13) param -> . type TIMES ID
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . VOID

    VOID            shift and go to state 23
    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    type                           shift and go to state 21
    params                         shift and go to state 22
    param_list                     shift and go to state 24
    param                          shift and go to state 25

state 16

    (33) idbracket -> ID LBRACKET . INUM RBRACKET

    INUM            shift and go to state 26


state 17

    (6) func_declaration -> type TIMES ID . LPAREN params RPAREN stmt_block
    (32) idbracket -> ID .
    (33) idbracket -> ID . LBRACKET INUM RBRACKET

    LPAREN          shift and go to state 27
    COMMA           reduce using rule 32 (idbracket -> ID .)
    INT             reduce using rule 32 (idbracket -> ID .)
    FLOAT           reduce using rule 32 (idbracket -> ID .)
    VOID            reduce using rule 32 (idbracket -> ID .)
    $end            reduce using rule 32 (idbracket -> ID .)
    LBRACKET        shift and go to state 16


state 18

    (29) declaration -> type TIMES id_list .
    (31) id_list -> id_list . COMMA idbracket

    INT             reduce using rule 29 (declaration -> type TIMES id_list .)
    FLOAT           reduce using rule 29 (declaration -> type TIMES id_list .)
    VOID            reduce using rule 29 (declaration -> type TIMES id_list .)
    $end            reduce using rule 29 (declaration -> type TIMES id_list .)
    SEMICOLON       reduce using rule 29 (declaration -> type TIMES id_list .)
    COMMA           shift and go to state 20


state 19

    (7) func_declaration -> type MAIN LPAREN . params RPAREN stmt_block
    (8) params -> . VOID
    (9) params -> . param_list
    (10) param_list -> . param
    (11) param_list -> . param_list COMMA param
    (12) param -> . type ID
    (13) param -> . type TIMES ID
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . VOID

    VOID            shift and go to state 23
    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    type                           shift and go to state 21
    params                         shift and go to state 28
    param_list                     shift and go to state 24
    param                          shift and go to state 25

state 20

    (31) id_list -> id_list COMMA . idbracket
    (32) idbracket -> . ID
    (33) idbracket -> . ID LBRACKET INUM RBRACKET

    ID              shift and go to state 30

    idbracket                      shift and go to state 29

state 21

    (12) param -> type . ID
    (13) param -> type . TIMES ID

    ID              shift and go to state 31
    TIMES           shift and go to state 32


state 22

    (5) func_declaration -> type ID LPAREN params . RPAREN stmt_block

    RPAREN          shift and go to state 33


state 23

    (8) params -> VOID .
    (36) type -> VOID .

    RPAREN          reduce using rule 8 (params -> VOID .)
    ID              reduce using rule 36 (type -> VOID .)
    TIMES           reduce using rule 36 (type -> VOID .)


state 24

    (9) params -> param_list .
    (11) param_list -> param_list . COMMA param

    RPAREN          reduce using rule 9 (params -> param_list .)
    COMMA           shift and go to state 34


state 25

    (10) param_list -> param .

    COMMA           reduce using rule 10 (param_list -> param .)
    RPAREN          reduce using rule 10 (param_list -> param .)


state 26

    (33) idbracket -> ID LBRACKET INUM . RBRACKET

    RBRACKET        shift and go to state 35


state 27

    (6) func_declaration -> type TIMES ID LPAREN . params RPAREN stmt_block
    (8) params -> . VOID
    (9) params -> . param_list
    (10) param_list -> . param
    (11) param_list -> . param_list COMMA param
    (12) param -> . type ID
    (13) param -> . type TIMES ID
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . VOID

    VOID            shift and go to state 23
    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    type                           shift and go to state 21
    params                         shift and go to state 36
    param_list                     shift and go to state 24
    param                          shift and go to state 25

state 28

    (7) func_declaration -> type MAIN LPAREN params . RPAREN stmt_block

    RPAREN          shift and go to state 37


state 29

    (31) id_list -> id_list COMMA idbracket .

    COMMA           reduce using rule 31 (id_list -> id_list COMMA idbracket .)
    INT             reduce using rule 31 (id_list -> id_list COMMA idbracket .)
    FLOAT           reduce using rule 31 (id_list -> id_list COMMA idbracket .)
    VOID            reduce using rule 31 (id_list -> id_list COMMA idbracket .)
    $end            reduce using rule 31 (id_list -> id_list COMMA idbracket .)
    SEMICOLON       reduce using rule 31 (id_list -> id_list COMMA idbracket .)


state 30

    (32) idbracket -> ID .
    (33) idbracket -> ID . LBRACKET INUM RBRACKET

    COMMA           reduce using rule 32 (idbracket -> ID .)
    INT             reduce using rule 32 (idbracket -> ID .)
    FLOAT           reduce using rule 32 (idbracket -> ID .)
    VOID            reduce using rule 32 (idbracket -> ID .)
    $end            reduce using rule 32 (idbracket -> ID .)
    SEMICOLON       reduce using rule 32 (idbracket -> ID .)
    LBRACKET        shift and go to state 16


state 31

    (12) param -> type ID .

    COMMA           reduce using rule 12 (param -> type ID .)
    RPAREN          reduce using rule 12 (param -> type ID .)


state 32

    (13) param -> type TIMES . ID

    ID              shift and go to state 38


state 33

    (5) func_declaration -> type ID LPAREN params RPAREN . stmt_block
    (37) stmt_block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 40

    stmt_block                     shift and go to state 39

state 34

    (11) param_list -> param_list COMMA . param
    (12) param -> . type ID
    (13) param -> . type TIMES ID
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . VOID

    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9

    param                          shift and go to state 41
    type                           shift and go to state 21

state 35

    (33) idbracket -> ID LBRACKET INUM RBRACKET .

    COMMA           reduce using rule 33 (idbracket -> ID LBRACKET INUM RBRACKET .)
    INT             reduce using rule 33 (idbracket -> ID LBRACKET INUM RBRACKET .)
    FLOAT           reduce using rule 33 (idbracket -> ID LBRACKET INUM RBRACKET .)
    VOID            reduce using rule 33 (idbracket -> ID LBRACKET INUM RBRACKET .)
    $end            reduce using rule 33 (idbracket -> ID LBRACKET INUM RBRACKET .)
    SEMICOLON       reduce using rule 33 (idbracket -> ID LBRACKET INUM RBRACKET .)


state 36

    (6) func_declaration -> type TIMES ID LPAREN params . RPAREN stmt_block

    RPAREN          shift and go to state 42


state 37

    (7) func_declaration -> type MAIN LPAREN params RPAREN . stmt_block
    (37) stmt_block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 40

    stmt_block                     shift and go to state 43

state 38

    (13) param -> type TIMES ID .

    COMMA           reduce using rule 13 (param -> type TIMES ID .)
    RPAREN          reduce using rule 13 (param -> type TIMES ID .)


state 39

    (5) func_declaration -> type ID LPAREN params RPAREN stmt_block .

    INT             reduce using rule 5 (func_declaration -> type ID LPAREN params RPAREN stmt_block .)
    FLOAT           reduce using rule 5 (func_declaration -> type ID LPAREN params RPAREN stmt_block .)
    VOID            reduce using rule 5 (func_declaration -> type ID LPAREN params RPAREN stmt_block .)
    $end            reduce using rule 5 (func_declaration -> type ID LPAREN params RPAREN stmt_block .)


state 40

    (37) stmt_block -> LBRACE . stmt_list RBRACE
    (38) stmt_list -> . stmt_list genstmt
    (39) stmt_list -> . empty
    (77) empty -> .

    RBRACE          reduce using rule 77 (empty -> .)
    IF              reduce using rule 77 (empty -> .)
    SEMICOLON       reduce using rule 77 (empty -> .)
    PRINT           reduce using rule 77 (empty -> .)
    ID              reduce using rule 77 (empty -> .)
    TIMES           reduce using rule 77 (empty -> .)
    LBRACE          reduce using rule 77 (empty -> .)
    FOR             reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)
    INCREMENT       reduce using rule 77 (empty -> .)
    INT             reduce using rule 77 (empty -> .)
    FLOAT           reduce using rule 77 (empty -> .)
    VOID            reduce using rule 77 (empty -> .)
    MINUS           reduce using rule 77 (empty -> .)
    LPAREN          reduce using rule 77 (empty -> .)
    FNUM            reduce using rule 77 (empty -> .)
    INUM            reduce using rule 77 (empty -> .)
    ADDRESS         reduce using rule 77 (empty -> .)

    stmt_list                      shift and go to state 44
    empty                          shift and go to state 45

state 41

    (11) param_list -> param_list COMMA param .

    COMMA           reduce using rule 11 (param_list -> param_list COMMA param .)
    RPAREN          reduce using rule 11 (param_list -> param_list COMMA param .)


state 42

    (6) func_declaration -> type TIMES ID LPAREN params RPAREN . stmt_block
    (37) stmt_block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 40

    stmt_block                     shift and go to state 46

state 43

    (7) func_declaration -> type MAIN LPAREN params RPAREN stmt_block .

    INT             reduce using rule 7 (func_declaration -> type MAIN LPAREN params RPAREN stmt_block .)
    FLOAT           reduce using rule 7 (func_declaration -> type MAIN LPAREN params RPAREN stmt_block .)
    VOID            reduce using rule 7 (func_declaration -> type MAIN LPAREN params RPAREN stmt_block .)
    $end            reduce using rule 7 (func_declaration -> type MAIN LPAREN params RPAREN stmt_block .)


state 44

    (37) stmt_block -> LBRACE stmt_list . RBRACE
    (38) stmt_list -> stmt_list . genstmt
    (14) genstmt -> . mstmt
    (15) genstmt -> . umstmt
    (16) mstmt -> . IF LPAREN expr RPAREN mstmt ELSE mstmt
    (17) mstmt -> . stmt
    (18) umstmt -> . IF LPAREN expr RPAREN genstmt
    (19) umstmt -> . IF LPAREN expr RPAREN mstmt ELSE umstmt
    (20) stmt -> . expr SEMICOLON
    (21) stmt -> . declaration SEMICOLON
    (22) stmt -> . stmt_block
    (23) stmt -> . stmt_forloop
    (24) stmt -> . stmt_return
    (25) stmt -> . SEMICOLON
    (26) stmt -> . expr error
    (27) stmt -> . PRINT LPAREN argument_list RPAREN
    (43) expr -> . ID EQUAL expr
    (44) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (45) expr -> . TIMES ID EQUAL expr
    (46) expr -> . incr_expr
    (47) expr -> . basic_expr
    (28) declaration -> . type id_list
    (29) declaration -> . type TIMES id_list
    (37) stmt_block -> . LBRACE stmt_list RBRACE
    (40) stmt_forloop -> . FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (41) stmt_return -> . RETURN expr SEMICOLON
    (42) stmt_return -> . RETURN SEMICOLON
    (54) incr_expr -> . ID INCREMENT
    (55) incr_expr -> . INCREMENT ID
    (48) basic_expr -> . basic_expr compare arith_expr
    (49) basic_expr -> . arith_expr
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . VOID
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    RBRACE          shift and go to state 47
    IF              shift and go to state 51
    SEMICOLON       shift and go to state 55
    PRINT           shift and go to state 60
    ID              shift and go to state 61
    TIMES           shift and go to state 63
    LBRACE          shift and go to state 40
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    INCREMENT       shift and go to state 69
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    genstmt                        shift and go to state 48
    mstmt                          shift and go to state 49
    umstmt                         shift and go to state 50
    expr                           shift and go to state 53
    stmt                           shift and go to state 54
    declaration                    shift and go to state 56
    stmt_block                     shift and go to state 57
    stmt_forloop                   shift and go to state 58
    stmt_return                    shift and go to state 59
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65
    type                           shift and go to state 66

state 45

    (39) stmt_list -> empty .

    RBRACE          reduce using rule 39 (stmt_list -> empty .)
    IF              reduce using rule 39 (stmt_list -> empty .)
    SEMICOLON       reduce using rule 39 (stmt_list -> empty .)
    PRINT           reduce using rule 39 (stmt_list -> empty .)
    ID              reduce using rule 39 (stmt_list -> empty .)
    TIMES           reduce using rule 39 (stmt_list -> empty .)
    LBRACE          reduce using rule 39 (stmt_list -> empty .)
    FOR             reduce using rule 39 (stmt_list -> empty .)
    RETURN          reduce using rule 39 (stmt_list -> empty .)
    INCREMENT       reduce using rule 39 (stmt_list -> empty .)
    INT             reduce using rule 39 (stmt_list -> empty .)
    FLOAT           reduce using rule 39 (stmt_list -> empty .)
    VOID            reduce using rule 39 (stmt_list -> empty .)
    MINUS           reduce using rule 39 (stmt_list -> empty .)
    LPAREN          reduce using rule 39 (stmt_list -> empty .)
    FNUM            reduce using rule 39 (stmt_list -> empty .)
    INUM            reduce using rule 39 (stmt_list -> empty .)
    ADDRESS         reduce using rule 39 (stmt_list -> empty .)


state 46

    (6) func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .

    INT             reduce using rule 6 (func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .)
    FLOAT           reduce using rule 6 (func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .)
    VOID            reduce using rule 6 (func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .)
    $end            reduce using rule 6 (func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .)


state 47

    (37) stmt_block -> LBRACE stmt_list RBRACE .

    INT             reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    $end            reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    IF              reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    SEMICOLON       reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    PRINT           reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    ID              reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    TIMES           reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    LBRACE          reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    INCREMENT       reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    MINUS           reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    LPAREN          reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    FNUM            reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    INUM            reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    ADDRESS         reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)
    ELSE            reduce using rule 37 (stmt_block -> LBRACE stmt_list RBRACE .)


state 48

    (38) stmt_list -> stmt_list genstmt .

    RBRACE          reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    IF              reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    SEMICOLON       reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    PRINT           reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    ID              reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    TIMES           reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    LBRACE          reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    FOR             reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    RETURN          reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    INCREMENT       reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    INT             reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    FLOAT           reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    VOID            reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    MINUS           reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    LPAREN          reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    FNUM            reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    INUM            reduce using rule 38 (stmt_list -> stmt_list genstmt .)
    ADDRESS         reduce using rule 38 (stmt_list -> stmt_list genstmt .)


state 49

    (14) genstmt -> mstmt .

    RBRACE          reduce using rule 14 (genstmt -> mstmt .)
    IF              reduce using rule 14 (genstmt -> mstmt .)
    SEMICOLON       reduce using rule 14 (genstmt -> mstmt .)
    PRINT           reduce using rule 14 (genstmt -> mstmt .)
    ID              reduce using rule 14 (genstmt -> mstmt .)
    TIMES           reduce using rule 14 (genstmt -> mstmt .)
    LBRACE          reduce using rule 14 (genstmt -> mstmt .)
    FOR             reduce using rule 14 (genstmt -> mstmt .)
    RETURN          reduce using rule 14 (genstmt -> mstmt .)
    INCREMENT       reduce using rule 14 (genstmt -> mstmt .)
    INT             reduce using rule 14 (genstmt -> mstmt .)
    FLOAT           reduce using rule 14 (genstmt -> mstmt .)
    VOID            reduce using rule 14 (genstmt -> mstmt .)
    MINUS           reduce using rule 14 (genstmt -> mstmt .)
    LPAREN          reduce using rule 14 (genstmt -> mstmt .)
    FNUM            reduce using rule 14 (genstmt -> mstmt .)
    INUM            reduce using rule 14 (genstmt -> mstmt .)
    ADDRESS         reduce using rule 14 (genstmt -> mstmt .)


state 50

    (15) genstmt -> umstmt .

    RBRACE          reduce using rule 15 (genstmt -> umstmt .)
    IF              reduce using rule 15 (genstmt -> umstmt .)
    SEMICOLON       reduce using rule 15 (genstmt -> umstmt .)
    PRINT           reduce using rule 15 (genstmt -> umstmt .)
    ID              reduce using rule 15 (genstmt -> umstmt .)
    TIMES           reduce using rule 15 (genstmt -> umstmt .)
    LBRACE          reduce using rule 15 (genstmt -> umstmt .)
    FOR             reduce using rule 15 (genstmt -> umstmt .)
    RETURN          reduce using rule 15 (genstmt -> umstmt .)
    INCREMENT       reduce using rule 15 (genstmt -> umstmt .)
    INT             reduce using rule 15 (genstmt -> umstmt .)
    FLOAT           reduce using rule 15 (genstmt -> umstmt .)
    VOID            reduce using rule 15 (genstmt -> umstmt .)
    MINUS           reduce using rule 15 (genstmt -> umstmt .)
    LPAREN          reduce using rule 15 (genstmt -> umstmt .)
    FNUM            reduce using rule 15 (genstmt -> umstmt .)
    INUM            reduce using rule 15 (genstmt -> umstmt .)
    ADDRESS         reduce using rule 15 (genstmt -> umstmt .)


state 51

    (16) mstmt -> IF . LPAREN expr RPAREN mstmt ELSE mstmt
    (18) umstmt -> IF . LPAREN expr RPAREN genstmt
    (19) umstmt -> IF . LPAREN expr RPAREN mstmt ELSE umstmt

    LPAREN          shift and go to state 74


state 52

    (57) arith_expr -> LPAREN . arith_expr RPAREN
    (58) arith_expr -> LPAREN . error
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    error           shift and go to state 76
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 78
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 77
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 75

state 53

    (20) stmt -> expr . SEMICOLON
    (26) stmt -> expr . error

    SEMICOLON       shift and go to state 79
    error           shift and go to state 80


state 54

    (17) mstmt -> stmt .

    RBRACE          reduce using rule 17 (mstmt -> stmt .)
    IF              reduce using rule 17 (mstmt -> stmt .)
    SEMICOLON       reduce using rule 17 (mstmt -> stmt .)
    PRINT           reduce using rule 17 (mstmt -> stmt .)
    ID              reduce using rule 17 (mstmt -> stmt .)
    TIMES           reduce using rule 17 (mstmt -> stmt .)
    LBRACE          reduce using rule 17 (mstmt -> stmt .)
    FOR             reduce using rule 17 (mstmt -> stmt .)
    RETURN          reduce using rule 17 (mstmt -> stmt .)
    INCREMENT       reduce using rule 17 (mstmt -> stmt .)
    INT             reduce using rule 17 (mstmt -> stmt .)
    FLOAT           reduce using rule 17 (mstmt -> stmt .)
    VOID            reduce using rule 17 (mstmt -> stmt .)
    MINUS           reduce using rule 17 (mstmt -> stmt .)
    LPAREN          reduce using rule 17 (mstmt -> stmt .)
    FNUM            reduce using rule 17 (mstmt -> stmt .)
    INUM            reduce using rule 17 (mstmt -> stmt .)
    ADDRESS         reduce using rule 17 (mstmt -> stmt .)
    ELSE            reduce using rule 17 (mstmt -> stmt .)


state 55

    (25) stmt -> SEMICOLON .

    RBRACE          reduce using rule 25 (stmt -> SEMICOLON .)
    IF              reduce using rule 25 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 25 (stmt -> SEMICOLON .)
    PRINT           reduce using rule 25 (stmt -> SEMICOLON .)
    ID              reduce using rule 25 (stmt -> SEMICOLON .)
    TIMES           reduce using rule 25 (stmt -> SEMICOLON .)
    LBRACE          reduce using rule 25 (stmt -> SEMICOLON .)
    FOR             reduce using rule 25 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 25 (stmt -> SEMICOLON .)
    INCREMENT       reduce using rule 25 (stmt -> SEMICOLON .)
    INT             reduce using rule 25 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 25 (stmt -> SEMICOLON .)
    VOID            reduce using rule 25 (stmt -> SEMICOLON .)
    MINUS           reduce using rule 25 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 25 (stmt -> SEMICOLON .)
    FNUM            reduce using rule 25 (stmt -> SEMICOLON .)
    INUM            reduce using rule 25 (stmt -> SEMICOLON .)
    ADDRESS         reduce using rule 25 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 25 (stmt -> SEMICOLON .)


state 56

    (21) stmt -> declaration . SEMICOLON

    SEMICOLON       shift and go to state 81


state 57

    (22) stmt -> stmt_block .

    RBRACE          reduce using rule 22 (stmt -> stmt_block .)
    IF              reduce using rule 22 (stmt -> stmt_block .)
    SEMICOLON       reduce using rule 22 (stmt -> stmt_block .)
    PRINT           reduce using rule 22 (stmt -> stmt_block .)
    ID              reduce using rule 22 (stmt -> stmt_block .)
    TIMES           reduce using rule 22 (stmt -> stmt_block .)
    LBRACE          reduce using rule 22 (stmt -> stmt_block .)
    FOR             reduce using rule 22 (stmt -> stmt_block .)
    RETURN          reduce using rule 22 (stmt -> stmt_block .)
    INCREMENT       reduce using rule 22 (stmt -> stmt_block .)
    INT             reduce using rule 22 (stmt -> stmt_block .)
    FLOAT           reduce using rule 22 (stmt -> stmt_block .)
    VOID            reduce using rule 22 (stmt -> stmt_block .)
    MINUS           reduce using rule 22 (stmt -> stmt_block .)
    LPAREN          reduce using rule 22 (stmt -> stmt_block .)
    FNUM            reduce using rule 22 (stmt -> stmt_block .)
    INUM            reduce using rule 22 (stmt -> stmt_block .)
    ADDRESS         reduce using rule 22 (stmt -> stmt_block .)
    ELSE            reduce using rule 22 (stmt -> stmt_block .)


state 58

    (23) stmt -> stmt_forloop .

    RBRACE          reduce using rule 23 (stmt -> stmt_forloop .)
    IF              reduce using rule 23 (stmt -> stmt_forloop .)
    SEMICOLON       reduce using rule 23 (stmt -> stmt_forloop .)
    PRINT           reduce using rule 23 (stmt -> stmt_forloop .)
    ID              reduce using rule 23 (stmt -> stmt_forloop .)
    TIMES           reduce using rule 23 (stmt -> stmt_forloop .)
    LBRACE          reduce using rule 23 (stmt -> stmt_forloop .)
    FOR             reduce using rule 23 (stmt -> stmt_forloop .)
    RETURN          reduce using rule 23 (stmt -> stmt_forloop .)
    INCREMENT       reduce using rule 23 (stmt -> stmt_forloop .)
    INT             reduce using rule 23 (stmt -> stmt_forloop .)
    FLOAT           reduce using rule 23 (stmt -> stmt_forloop .)
    VOID            reduce using rule 23 (stmt -> stmt_forloop .)
    MINUS           reduce using rule 23 (stmt -> stmt_forloop .)
    LPAREN          reduce using rule 23 (stmt -> stmt_forloop .)
    FNUM            reduce using rule 23 (stmt -> stmt_forloop .)
    INUM            reduce using rule 23 (stmt -> stmt_forloop .)
    ADDRESS         reduce using rule 23 (stmt -> stmt_forloop .)
    ELSE            reduce using rule 23 (stmt -> stmt_forloop .)


state 59

    (24) stmt -> stmt_return .

    RBRACE          reduce using rule 24 (stmt -> stmt_return .)
    IF              reduce using rule 24 (stmt -> stmt_return .)
    SEMICOLON       reduce using rule 24 (stmt -> stmt_return .)
    PRINT           reduce using rule 24 (stmt -> stmt_return .)
    ID              reduce using rule 24 (stmt -> stmt_return .)
    TIMES           reduce using rule 24 (stmt -> stmt_return .)
    LBRACE          reduce using rule 24 (stmt -> stmt_return .)
    FOR             reduce using rule 24 (stmt -> stmt_return .)
    RETURN          reduce using rule 24 (stmt -> stmt_return .)
    INCREMENT       reduce using rule 24 (stmt -> stmt_return .)
    INT             reduce using rule 24 (stmt -> stmt_return .)
    FLOAT           reduce using rule 24 (stmt -> stmt_return .)
    VOID            reduce using rule 24 (stmt -> stmt_return .)
    MINUS           reduce using rule 24 (stmt -> stmt_return .)
    LPAREN          reduce using rule 24 (stmt -> stmt_return .)
    FNUM            reduce using rule 24 (stmt -> stmt_return .)
    INUM            reduce using rule 24 (stmt -> stmt_return .)
    ADDRESS         reduce using rule 24 (stmt -> stmt_return .)
    ELSE            reduce using rule 24 (stmt -> stmt_return .)


state 60

    (27) stmt -> PRINT . LPAREN argument_list RPAREN

    LPAREN          shift and go to state 82


state 61

    (43) expr -> ID . EQUAL expr
    (44) expr -> ID . LBRACKET arith_expr RBRACKET EQUAL expr
    (54) incr_expr -> ID . INCREMENT
    (63) arith_expr -> ID .
    (68) arith_expr -> ID . LBRACKET arith_expr RBRACKET
    (69) arith_expr -> ID . LPAREN argument_list RPAREN
    (70) arith_expr -> ID . LPAREN argument_list error

    EQUAL           shift and go to state 83
    LBRACKET        shift and go to state 84
    INCREMENT       shift and go to state 85
    PLUS            reduce using rule 63 (arith_expr -> ID .)
    MINUS           reduce using rule 63 (arith_expr -> ID .)
    TIMES           reduce using rule 63 (arith_expr -> ID .)
    DIV             reduce using rule 63 (arith_expr -> ID .)
    EQ              reduce using rule 63 (arith_expr -> ID .)
    NEQ             reduce using rule 63 (arith_expr -> ID .)
    GT              reduce using rule 63 (arith_expr -> ID .)
    LT              reduce using rule 63 (arith_expr -> ID .)
    SEMICOLON       reduce using rule 63 (arith_expr -> ID .)
    error           reduce using rule 63 (arith_expr -> ID .)
    RPAREN          reduce using rule 63 (arith_expr -> ID .)
    LPAREN          shift and go to state 86


state 62

    (49) basic_expr -> arith_expr .
    (59) arith_expr -> arith_expr . PLUS arith_expr
    (60) arith_expr -> arith_expr . MINUS arith_expr
    (61) arith_expr -> arith_expr . TIMES arith_expr
    (62) arith_expr -> arith_expr . DIV arith_expr

    EQ              reduce using rule 49 (basic_expr -> arith_expr .)
    NEQ             reduce using rule 49 (basic_expr -> arith_expr .)
    GT              reduce using rule 49 (basic_expr -> arith_expr .)
    LT              reduce using rule 49 (basic_expr -> arith_expr .)
    SEMICOLON       reduce using rule 49 (basic_expr -> arith_expr .)
    error           reduce using rule 49 (basic_expr -> arith_expr .)
    RPAREN          reduce using rule 49 (basic_expr -> arith_expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIV             shift and go to state 90


state 63

    (45) expr -> TIMES . ID EQUAL expr
    (66) arith_expr -> TIMES . ID

    ID              shift and go to state 91


state 64

    (46) expr -> incr_expr .

    SEMICOLON       reduce using rule 46 (expr -> incr_expr .)
    error           reduce using rule 46 (expr -> incr_expr .)
    RPAREN          reduce using rule 46 (expr -> incr_expr .)


state 65

    (47) expr -> basic_expr .
    (48) basic_expr -> basic_expr . compare arith_expr
    (50) compare -> . EQ
    (51) compare -> . NEQ
    (52) compare -> . GT
    (53) compare -> . LT

    SEMICOLON       reduce using rule 47 (expr -> basic_expr .)
    error           reduce using rule 47 (expr -> basic_expr .)
    RPAREN          reduce using rule 47 (expr -> basic_expr .)
    EQ              shift and go to state 93
    NEQ             shift and go to state 94
    GT              shift and go to state 95
    LT              shift and go to state 96

    compare                        shift and go to state 92

state 66

    (28) declaration -> type . id_list
    (29) declaration -> type . TIMES id_list
    (30) id_list -> . idbracket
    (31) id_list -> . id_list COMMA idbracket
    (32) idbracket -> . ID
    (33) idbracket -> . ID LBRACKET INUM RBRACKET

    TIMES           shift and go to state 97
    ID              shift and go to state 30

    id_list                        shift and go to state 13
    idbracket                      shift and go to state 14

state 67

    (40) stmt_forloop -> FOR . LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt

    LPAREN          shift and go to state 98


state 68

    (41) stmt_return -> RETURN . expr SEMICOLON
    (42) stmt_return -> RETURN . SEMICOLON
    (43) expr -> . ID EQUAL expr
    (44) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (45) expr -> . TIMES ID EQUAL expr
    (46) expr -> . incr_expr
    (47) expr -> . basic_expr
    (54) incr_expr -> . ID INCREMENT
    (55) incr_expr -> . INCREMENT ID
    (48) basic_expr -> . basic_expr compare arith_expr
    (49) basic_expr -> . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    SEMICOLON       shift and go to state 100
    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 99
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 69

    (55) incr_expr -> INCREMENT . ID

    ID              shift and go to state 101


state 70

    (56) arith_expr -> MINUS . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 78
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 77
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 102

state 71

    (64) arith_expr -> FNUM .

    PLUS            reduce using rule 64 (arith_expr -> FNUM .)
    MINUS           reduce using rule 64 (arith_expr -> FNUM .)
    TIMES           reduce using rule 64 (arith_expr -> FNUM .)
    DIV             reduce using rule 64 (arith_expr -> FNUM .)
    EQ              reduce using rule 64 (arith_expr -> FNUM .)
    NEQ             reduce using rule 64 (arith_expr -> FNUM .)
    GT              reduce using rule 64 (arith_expr -> FNUM .)
    LT              reduce using rule 64 (arith_expr -> FNUM .)
    SEMICOLON       reduce using rule 64 (arith_expr -> FNUM .)
    error           reduce using rule 64 (arith_expr -> FNUM .)
    RPAREN          reduce using rule 64 (arith_expr -> FNUM .)
    COMMA           reduce using rule 64 (arith_expr -> FNUM .)
    RBRACKET        reduce using rule 64 (arith_expr -> FNUM .)


state 72

    (65) arith_expr -> INUM .

    PLUS            reduce using rule 65 (arith_expr -> INUM .)
    MINUS           reduce using rule 65 (arith_expr -> INUM .)
    TIMES           reduce using rule 65 (arith_expr -> INUM .)
    DIV             reduce using rule 65 (arith_expr -> INUM .)
    EQ              reduce using rule 65 (arith_expr -> INUM .)
    NEQ             reduce using rule 65 (arith_expr -> INUM .)
    GT              reduce using rule 65 (arith_expr -> INUM .)
    LT              reduce using rule 65 (arith_expr -> INUM .)
    SEMICOLON       reduce using rule 65 (arith_expr -> INUM .)
    error           reduce using rule 65 (arith_expr -> INUM .)
    RPAREN          reduce using rule 65 (arith_expr -> INUM .)
    COMMA           reduce using rule 65 (arith_expr -> INUM .)
    RBRACKET        reduce using rule 65 (arith_expr -> INUM .)


state 73

    (67) arith_expr -> ADDRESS . ID

    ID              shift and go to state 103


state 74

    (16) mstmt -> IF LPAREN . expr RPAREN mstmt ELSE mstmt
    (18) umstmt -> IF LPAREN . expr RPAREN genstmt
    (19) umstmt -> IF LPAREN . expr RPAREN mstmt ELSE umstmt
    (43) expr -> . ID EQUAL expr
    (44) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (45) expr -> . TIMES ID EQUAL expr
    (46) expr -> . incr_expr
    (47) expr -> . basic_expr
    (54) incr_expr -> . ID INCREMENT
    (55) incr_expr -> . INCREMENT ID
    (48) basic_expr -> . basic_expr compare arith_expr
    (49) basic_expr -> . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 104
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 75

    (57) arith_expr -> LPAREN arith_expr . RPAREN
    (59) arith_expr -> arith_expr . PLUS arith_expr
    (60) arith_expr -> arith_expr . MINUS arith_expr
    (61) arith_expr -> arith_expr . TIMES arith_expr
    (62) arith_expr -> arith_expr . DIV arith_expr

    RPAREN          shift and go to state 105
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIV             shift and go to state 90


state 76

    (58) arith_expr -> LPAREN error .

    PLUS            reduce using rule 58 (arith_expr -> LPAREN error .)
    MINUS           reduce using rule 58 (arith_expr -> LPAREN error .)
    TIMES           reduce using rule 58 (arith_expr -> LPAREN error .)
    DIV             reduce using rule 58 (arith_expr -> LPAREN error .)
    EQ              reduce using rule 58 (arith_expr -> LPAREN error .)
    NEQ             reduce using rule 58 (arith_expr -> LPAREN error .)
    GT              reduce using rule 58 (arith_expr -> LPAREN error .)
    LT              reduce using rule 58 (arith_expr -> LPAREN error .)
    SEMICOLON       reduce using rule 58 (arith_expr -> LPAREN error .)
    error           reduce using rule 58 (arith_expr -> LPAREN error .)
    RPAREN          reduce using rule 58 (arith_expr -> LPAREN error .)
    COMMA           reduce using rule 58 (arith_expr -> LPAREN error .)
    RBRACKET        reduce using rule 58 (arith_expr -> LPAREN error .)


state 77

    (66) arith_expr -> TIMES . ID

    ID              shift and go to state 106


state 78

    (63) arith_expr -> ID .
    (68) arith_expr -> ID . LBRACKET arith_expr RBRACKET
    (69) arith_expr -> ID . LPAREN argument_list RPAREN
    (70) arith_expr -> ID . LPAREN argument_list error

    RPAREN          reduce using rule 63 (arith_expr -> ID .)
    PLUS            reduce using rule 63 (arith_expr -> ID .)
    MINUS           reduce using rule 63 (arith_expr -> ID .)
    TIMES           reduce using rule 63 (arith_expr -> ID .)
    DIV             reduce using rule 63 (arith_expr -> ID .)
    EQ              reduce using rule 63 (arith_expr -> ID .)
    NEQ             reduce using rule 63 (arith_expr -> ID .)
    GT              reduce using rule 63 (arith_expr -> ID .)
    LT              reduce using rule 63 (arith_expr -> ID .)
    SEMICOLON       reduce using rule 63 (arith_expr -> ID .)
    error           reduce using rule 63 (arith_expr -> ID .)
    COMMA           reduce using rule 63 (arith_expr -> ID .)
    RBRACKET        reduce using rule 63 (arith_expr -> ID .)
    LBRACKET        shift and go to state 107
    LPAREN          shift and go to state 86


state 79

    (20) stmt -> expr SEMICOLON .

    RBRACE          reduce using rule 20 (stmt -> expr SEMICOLON .)
    IF              reduce using rule 20 (stmt -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 20 (stmt -> expr SEMICOLON .)
    PRINT           reduce using rule 20 (stmt -> expr SEMICOLON .)
    ID              reduce using rule 20 (stmt -> expr SEMICOLON .)
    TIMES           reduce using rule 20 (stmt -> expr SEMICOLON .)
    LBRACE          reduce using rule 20 (stmt -> expr SEMICOLON .)
    FOR             reduce using rule 20 (stmt -> expr SEMICOLON .)
    RETURN          reduce using rule 20 (stmt -> expr SEMICOLON .)
    INCREMENT       reduce using rule 20 (stmt -> expr SEMICOLON .)
    INT             reduce using rule 20 (stmt -> expr SEMICOLON .)
    FLOAT           reduce using rule 20 (stmt -> expr SEMICOLON .)
    VOID            reduce using rule 20 (stmt -> expr SEMICOLON .)
    MINUS           reduce using rule 20 (stmt -> expr SEMICOLON .)
    LPAREN          reduce using rule 20 (stmt -> expr SEMICOLON .)
    FNUM            reduce using rule 20 (stmt -> expr SEMICOLON .)
    INUM            reduce using rule 20 (stmt -> expr SEMICOLON .)
    ADDRESS         reduce using rule 20 (stmt -> expr SEMICOLON .)
    ELSE            reduce using rule 20 (stmt -> expr SEMICOLON .)


state 80

    (26) stmt -> expr error .

    RBRACE          reduce using rule 26 (stmt -> expr error .)
    IF              reduce using rule 26 (stmt -> expr error .)
    SEMICOLON       reduce using rule 26 (stmt -> expr error .)
    PRINT           reduce using rule 26 (stmt -> expr error .)
    ID              reduce using rule 26 (stmt -> expr error .)
    TIMES           reduce using rule 26 (stmt -> expr error .)
    LBRACE          reduce using rule 26 (stmt -> expr error .)
    FOR             reduce using rule 26 (stmt -> expr error .)
    RETURN          reduce using rule 26 (stmt -> expr error .)
    INCREMENT       reduce using rule 26 (stmt -> expr error .)
    INT             reduce using rule 26 (stmt -> expr error .)
    FLOAT           reduce using rule 26 (stmt -> expr error .)
    VOID            reduce using rule 26 (stmt -> expr error .)
    MINUS           reduce using rule 26 (stmt -> expr error .)
    LPAREN          reduce using rule 26 (stmt -> expr error .)
    FNUM            reduce using rule 26 (stmt -> expr error .)
    INUM            reduce using rule 26 (stmt -> expr error .)
    ADDRESS         reduce using rule 26 (stmt -> expr error .)
    ELSE            reduce using rule 26 (stmt -> expr error .)


state 81

    (21) stmt -> declaration SEMICOLON .

    RBRACE          reduce using rule 21 (stmt -> declaration SEMICOLON .)
    IF              reduce using rule 21 (stmt -> declaration SEMICOLON .)
    SEMICOLON       reduce using rule 21 (stmt -> declaration SEMICOLON .)
    PRINT           reduce using rule 21 (stmt -> declaration SEMICOLON .)
    ID              reduce using rule 21 (stmt -> declaration SEMICOLON .)
    TIMES           reduce using rule 21 (stmt -> declaration SEMICOLON .)
    LBRACE          reduce using rule 21 (stmt -> declaration SEMICOLON .)
    FOR             reduce using rule 21 (stmt -> declaration SEMICOLON .)
    RETURN          reduce using rule 21 (stmt -> declaration SEMICOLON .)
    INCREMENT       reduce using rule 21 (stmt -> declaration SEMICOLON .)
    INT             reduce using rule 21 (stmt -> declaration SEMICOLON .)
    FLOAT           reduce using rule 21 (stmt -> declaration SEMICOLON .)
    VOID            reduce using rule 21 (stmt -> declaration SEMICOLON .)
    MINUS           reduce using rule 21 (stmt -> declaration SEMICOLON .)
    LPAREN          reduce using rule 21 (stmt -> declaration SEMICOLON .)
    FNUM            reduce using rule 21 (stmt -> declaration SEMICOLON .)
    INUM            reduce using rule 21 (stmt -> declaration SEMICOLON .)
    ADDRESS         reduce using rule 21 (stmt -> declaration SEMICOLON .)
    ELSE            reduce using rule 21 (stmt -> declaration SEMICOLON .)


state 82

    (27) stmt -> PRINT LPAREN . argument_list RPAREN
    (71) argument_list -> . argument
    (72) argument_list -> . argument_list COMMA argument
    (73) argument -> . empty
    (74) argument -> . arith_expr
    (75) argument -> . LITERAL
    (76) argument -> . error
    (77) empty -> .
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    LITERAL         shift and go to state 112
    error           shift and go to state 113
    RPAREN          reduce using rule 77 (empty -> .)
    COMMA           reduce using rule 77 (empty -> .)
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 78
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 77
    ADDRESS         shift and go to state 73

    argument_list                  shift and go to state 108
    argument                       shift and go to state 109
    empty                          shift and go to state 110
    arith_expr                     shift and go to state 111

state 83

    (43) expr -> ID EQUAL . expr
    (43) expr -> . ID EQUAL expr
    (44) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (45) expr -> . TIMES ID EQUAL expr
    (46) expr -> . incr_expr
    (47) expr -> . basic_expr
    (54) incr_expr -> . ID INCREMENT
    (55) incr_expr -> . INCREMENT ID
    (48) basic_expr -> . basic_expr compare arith_expr
    (49) basic_expr -> . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 114
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 84

    (44) expr -> ID LBRACKET . arith_expr RBRACKET EQUAL expr
    (68) arith_expr -> ID LBRACKET . arith_expr RBRACKET
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 78
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 77
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 115

state 85

    (54) incr_expr -> ID INCREMENT .

    SEMICOLON       reduce using rule 54 (incr_expr -> ID INCREMENT .)
    error           reduce using rule 54 (incr_expr -> ID INCREMENT .)
    RPAREN          reduce using rule 54 (incr_expr -> ID INCREMENT .)


state 86

    (69) arith_expr -> ID LPAREN . argument_list RPAREN
    (70) arith_expr -> ID LPAREN . argument_list error
    (71) argument_list -> . argument
    (72) argument_list -> . argument_list COMMA argument
    (73) argument -> . empty
    (74) argument -> . arith_expr
    (75) argument -> . LITERAL
    (76) argument -> . error
    (77) empty -> .
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

  ! shift/reduce conflict for error resolved as shift
    LITERAL         shift and go to state 112
    error           shift and go to state 113
    RPAREN          reduce using rule 77 (empty -> .)
    COMMA           reduce using rule 77 (empty -> .)
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 78
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 77
    ADDRESS         shift and go to state 73

  ! error           [ reduce using rule 77 (empty -> .) ]

    argument_list                  shift and go to state 116
    argument                       shift and go to state 109
    empty                          shift and go to state 110
    arith_expr                     shift and go to state 111

state 87

    (59) arith_expr -> arith_expr PLUS . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 78
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 77
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 117

state 88

    (60) arith_expr -> arith_expr MINUS . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 78
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 77
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 118

state 89

    (61) arith_expr -> arith_expr TIMES . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 78
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 77
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 119

state 90

    (62) arith_expr -> arith_expr DIV . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 78
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 77
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 120

state 91

    (45) expr -> TIMES ID . EQUAL expr
    (66) arith_expr -> TIMES ID .

    EQUAL           shift and go to state 121
    PLUS            reduce using rule 66 (arith_expr -> TIMES ID .)
    MINUS           reduce using rule 66 (arith_expr -> TIMES ID .)
    TIMES           reduce using rule 66 (arith_expr -> TIMES ID .)
    DIV             reduce using rule 66 (arith_expr -> TIMES ID .)
    EQ              reduce using rule 66 (arith_expr -> TIMES ID .)
    NEQ             reduce using rule 66 (arith_expr -> TIMES ID .)
    GT              reduce using rule 66 (arith_expr -> TIMES ID .)
    LT              reduce using rule 66 (arith_expr -> TIMES ID .)
    SEMICOLON       reduce using rule 66 (arith_expr -> TIMES ID .)
    error           reduce using rule 66 (arith_expr -> TIMES ID .)
    RPAREN          reduce using rule 66 (arith_expr -> TIMES ID .)


state 92

    (48) basic_expr -> basic_expr compare . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 78
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 77
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 122

state 93

    (50) compare -> EQ .

    MINUS           reduce using rule 50 (compare -> EQ .)
    LPAREN          reduce using rule 50 (compare -> EQ .)
    ID              reduce using rule 50 (compare -> EQ .)
    FNUM            reduce using rule 50 (compare -> EQ .)
    INUM            reduce using rule 50 (compare -> EQ .)
    TIMES           reduce using rule 50 (compare -> EQ .)
    ADDRESS         reduce using rule 50 (compare -> EQ .)


state 94

    (51) compare -> NEQ .

    MINUS           reduce using rule 51 (compare -> NEQ .)
    LPAREN          reduce using rule 51 (compare -> NEQ .)
    ID              reduce using rule 51 (compare -> NEQ .)
    FNUM            reduce using rule 51 (compare -> NEQ .)
    INUM            reduce using rule 51 (compare -> NEQ .)
    TIMES           reduce using rule 51 (compare -> NEQ .)
    ADDRESS         reduce using rule 51 (compare -> NEQ .)


state 95

    (52) compare -> GT .

    MINUS           reduce using rule 52 (compare -> GT .)
    LPAREN          reduce using rule 52 (compare -> GT .)
    ID              reduce using rule 52 (compare -> GT .)
    FNUM            reduce using rule 52 (compare -> GT .)
    INUM            reduce using rule 52 (compare -> GT .)
    TIMES           reduce using rule 52 (compare -> GT .)
    ADDRESS         reduce using rule 52 (compare -> GT .)


state 96

    (53) compare -> LT .

    MINUS           reduce using rule 53 (compare -> LT .)
    LPAREN          reduce using rule 53 (compare -> LT .)
    ID              reduce using rule 53 (compare -> LT .)
    FNUM            reduce using rule 53 (compare -> LT .)
    INUM            reduce using rule 53 (compare -> LT .)
    TIMES           reduce using rule 53 (compare -> LT .)
    ADDRESS         reduce using rule 53 (compare -> LT .)


state 97

    (29) declaration -> type TIMES . id_list
    (30) id_list -> . idbracket
    (31) id_list -> . id_list COMMA idbracket
    (32) idbracket -> . ID
    (33) idbracket -> . ID LBRACKET INUM RBRACKET

    ID              shift and go to state 30

    id_list                        shift and go to state 18
    idbracket                      shift and go to state 14

state 98

    (40) stmt_forloop -> FOR LPAREN . expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (43) expr -> . ID EQUAL expr
    (44) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (45) expr -> . TIMES ID EQUAL expr
    (46) expr -> . incr_expr
    (47) expr -> . basic_expr
    (54) incr_expr -> . ID INCREMENT
    (55) incr_expr -> . INCREMENT ID
    (48) basic_expr -> . basic_expr compare arith_expr
    (49) basic_expr -> . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 123
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 99

    (41) stmt_return -> RETURN expr . SEMICOLON

    SEMICOLON       shift and go to state 124


state 100

    (42) stmt_return -> RETURN SEMICOLON .

    RBRACE          reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    IF              reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    PRINT           reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    ID              reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    TIMES           reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    FOR             reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    RETURN          reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    INCREMENT       reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    INT             reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    VOID            reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    MINUS           reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    FNUM            reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    INUM            reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    ADDRESS         reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)
    ELSE            reduce using rule 42 (stmt_return -> RETURN SEMICOLON .)


state 101

    (55) incr_expr -> INCREMENT ID .

    SEMICOLON       reduce using rule 55 (incr_expr -> INCREMENT ID .)
    error           reduce using rule 55 (incr_expr -> INCREMENT ID .)
    RPAREN          reduce using rule 55 (incr_expr -> INCREMENT ID .)


state 102

    (56) arith_expr -> MINUS arith_expr .
    (59) arith_expr -> arith_expr . PLUS arith_expr
    (60) arith_expr -> arith_expr . MINUS arith_expr
    (61) arith_expr -> arith_expr . TIMES arith_expr
    (62) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 56 (arith_expr -> MINUS arith_expr .)
    MINUS           reduce using rule 56 (arith_expr -> MINUS arith_expr .)
    TIMES           reduce using rule 56 (arith_expr -> MINUS arith_expr .)
    DIV             reduce using rule 56 (arith_expr -> MINUS arith_expr .)
    EQ              reduce using rule 56 (arith_expr -> MINUS arith_expr .)
    NEQ             reduce using rule 56 (arith_expr -> MINUS arith_expr .)
    GT              reduce using rule 56 (arith_expr -> MINUS arith_expr .)
    LT              reduce using rule 56 (arith_expr -> MINUS arith_expr .)
    SEMICOLON       reduce using rule 56 (arith_expr -> MINUS arith_expr .)
    error           reduce using rule 56 (arith_expr -> MINUS arith_expr .)
    RPAREN          reduce using rule 56 (arith_expr -> MINUS arith_expr .)
    COMMA           reduce using rule 56 (arith_expr -> MINUS arith_expr .)
    RBRACKET        reduce using rule 56 (arith_expr -> MINUS arith_expr .)

  ! PLUS            [ shift and go to state 87 ]
  ! MINUS           [ shift and go to state 88 ]
  ! TIMES           [ shift and go to state 89 ]
  ! DIV             [ shift and go to state 90 ]


state 103

    (67) arith_expr -> ADDRESS ID .

    PLUS            reduce using rule 67 (arith_expr -> ADDRESS ID .)
    MINUS           reduce using rule 67 (arith_expr -> ADDRESS ID .)
    TIMES           reduce using rule 67 (arith_expr -> ADDRESS ID .)
    DIV             reduce using rule 67 (arith_expr -> ADDRESS ID .)
    EQ              reduce using rule 67 (arith_expr -> ADDRESS ID .)
    NEQ             reduce using rule 67 (arith_expr -> ADDRESS ID .)
    GT              reduce using rule 67 (arith_expr -> ADDRESS ID .)
    LT              reduce using rule 67 (arith_expr -> ADDRESS ID .)
    SEMICOLON       reduce using rule 67 (arith_expr -> ADDRESS ID .)
    error           reduce using rule 67 (arith_expr -> ADDRESS ID .)
    RPAREN          reduce using rule 67 (arith_expr -> ADDRESS ID .)
    COMMA           reduce using rule 67 (arith_expr -> ADDRESS ID .)
    RBRACKET        reduce using rule 67 (arith_expr -> ADDRESS ID .)


state 104

    (16) mstmt -> IF LPAREN expr . RPAREN mstmt ELSE mstmt
    (18) umstmt -> IF LPAREN expr . RPAREN genstmt
    (19) umstmt -> IF LPAREN expr . RPAREN mstmt ELSE umstmt

    RPAREN          shift and go to state 125


state 105

    (57) arith_expr -> LPAREN arith_expr RPAREN .

    PLUS            reduce using rule 57 (arith_expr -> LPAREN arith_expr RPAREN .)
    MINUS           reduce using rule 57 (arith_expr -> LPAREN arith_expr RPAREN .)
    TIMES           reduce using rule 57 (arith_expr -> LPAREN arith_expr RPAREN .)
    DIV             reduce using rule 57 (arith_expr -> LPAREN arith_expr RPAREN .)
    EQ              reduce using rule 57 (arith_expr -> LPAREN arith_expr RPAREN .)
    NEQ             reduce using rule 57 (arith_expr -> LPAREN arith_expr RPAREN .)
    GT              reduce using rule 57 (arith_expr -> LPAREN arith_expr RPAREN .)
    LT              reduce using rule 57 (arith_expr -> LPAREN arith_expr RPAREN .)
    SEMICOLON       reduce using rule 57 (arith_expr -> LPAREN arith_expr RPAREN .)
    error           reduce using rule 57 (arith_expr -> LPAREN arith_expr RPAREN .)
    RPAREN          reduce using rule 57 (arith_expr -> LPAREN arith_expr RPAREN .)
    COMMA           reduce using rule 57 (arith_expr -> LPAREN arith_expr RPAREN .)
    RBRACKET        reduce using rule 57 (arith_expr -> LPAREN arith_expr RPAREN .)


state 106

    (66) arith_expr -> TIMES ID .

    RPAREN          reduce using rule 66 (arith_expr -> TIMES ID .)
    PLUS            reduce using rule 66 (arith_expr -> TIMES ID .)
    MINUS           reduce using rule 66 (arith_expr -> TIMES ID .)
    TIMES           reduce using rule 66 (arith_expr -> TIMES ID .)
    DIV             reduce using rule 66 (arith_expr -> TIMES ID .)
    EQ              reduce using rule 66 (arith_expr -> TIMES ID .)
    NEQ             reduce using rule 66 (arith_expr -> TIMES ID .)
    GT              reduce using rule 66 (arith_expr -> TIMES ID .)
    LT              reduce using rule 66 (arith_expr -> TIMES ID .)
    SEMICOLON       reduce using rule 66 (arith_expr -> TIMES ID .)
    error           reduce using rule 66 (arith_expr -> TIMES ID .)
    COMMA           reduce using rule 66 (arith_expr -> TIMES ID .)
    RBRACKET        reduce using rule 66 (arith_expr -> TIMES ID .)


state 107

    (68) arith_expr -> ID LBRACKET . arith_expr RBRACKET
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 78
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 77
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 126

state 108

    (27) stmt -> PRINT LPAREN argument_list . RPAREN
    (72) argument_list -> argument_list . COMMA argument

    RPAREN          shift and go to state 127
    COMMA           shift and go to state 128


state 109

    (71) argument_list -> argument .

    RPAREN          reduce using rule 71 (argument_list -> argument .)
    COMMA           reduce using rule 71 (argument_list -> argument .)
    error           reduce using rule 71 (argument_list -> argument .)


state 110

    (73) argument -> empty .

    RPAREN          reduce using rule 73 (argument -> empty .)
    COMMA           reduce using rule 73 (argument -> empty .)
    error           reduce using rule 73 (argument -> empty .)


state 111

    (74) argument -> arith_expr .
    (59) arith_expr -> arith_expr . PLUS arith_expr
    (60) arith_expr -> arith_expr . MINUS arith_expr
    (61) arith_expr -> arith_expr . TIMES arith_expr
    (62) arith_expr -> arith_expr . DIV arith_expr

    RPAREN          reduce using rule 74 (argument -> arith_expr .)
    COMMA           reduce using rule 74 (argument -> arith_expr .)
    error           reduce using rule 74 (argument -> arith_expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIV             shift and go to state 90


state 112

    (75) argument -> LITERAL .

    RPAREN          reduce using rule 75 (argument -> LITERAL .)
    COMMA           reduce using rule 75 (argument -> LITERAL .)
    error           reduce using rule 75 (argument -> LITERAL .)


state 113

    (76) argument -> error .

    RPAREN          reduce using rule 76 (argument -> error .)
    COMMA           reduce using rule 76 (argument -> error .)
    error           reduce using rule 76 (argument -> error .)


state 114

    (43) expr -> ID EQUAL expr .

    SEMICOLON       reduce using rule 43 (expr -> ID EQUAL expr .)
    error           reduce using rule 43 (expr -> ID EQUAL expr .)
    RPAREN          reduce using rule 43 (expr -> ID EQUAL expr .)


state 115

    (44) expr -> ID LBRACKET arith_expr . RBRACKET EQUAL expr
    (68) arith_expr -> ID LBRACKET arith_expr . RBRACKET
    (59) arith_expr -> arith_expr . PLUS arith_expr
    (60) arith_expr -> arith_expr . MINUS arith_expr
    (61) arith_expr -> arith_expr . TIMES arith_expr
    (62) arith_expr -> arith_expr . DIV arith_expr

    RBRACKET        shift and go to state 129
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIV             shift and go to state 90


state 116

    (69) arith_expr -> ID LPAREN argument_list . RPAREN
    (70) arith_expr -> ID LPAREN argument_list . error
    (72) argument_list -> argument_list . COMMA argument

    RPAREN          shift and go to state 130
    error           shift and go to state 131
    COMMA           shift and go to state 128


state 117

    (59) arith_expr -> arith_expr PLUS arith_expr .
    (59) arith_expr -> arith_expr . PLUS arith_expr
    (60) arith_expr -> arith_expr . MINUS arith_expr
    (61) arith_expr -> arith_expr . TIMES arith_expr
    (62) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 59 (arith_expr -> arith_expr PLUS arith_expr .)
    MINUS           reduce using rule 59 (arith_expr -> arith_expr PLUS arith_expr .)
    EQ              reduce using rule 59 (arith_expr -> arith_expr PLUS arith_expr .)
    NEQ             reduce using rule 59 (arith_expr -> arith_expr PLUS arith_expr .)
    GT              reduce using rule 59 (arith_expr -> arith_expr PLUS arith_expr .)
    LT              reduce using rule 59 (arith_expr -> arith_expr PLUS arith_expr .)
    SEMICOLON       reduce using rule 59 (arith_expr -> arith_expr PLUS arith_expr .)
    error           reduce using rule 59 (arith_expr -> arith_expr PLUS arith_expr .)
    RPAREN          reduce using rule 59 (arith_expr -> arith_expr PLUS arith_expr .)
    COMMA           reduce using rule 59 (arith_expr -> arith_expr PLUS arith_expr .)
    RBRACKET        reduce using rule 59 (arith_expr -> arith_expr PLUS arith_expr .)
    TIMES           shift and go to state 89
    DIV             shift and go to state 90

  ! TIMES           [ reduce using rule 59 (arith_expr -> arith_expr PLUS arith_expr .) ]
  ! DIV             [ reduce using rule 59 (arith_expr -> arith_expr PLUS arith_expr .) ]
  ! PLUS            [ shift and go to state 87 ]
  ! MINUS           [ shift and go to state 88 ]


state 118

    (60) arith_expr -> arith_expr MINUS arith_expr .
    (59) arith_expr -> arith_expr . PLUS arith_expr
    (60) arith_expr -> arith_expr . MINUS arith_expr
    (61) arith_expr -> arith_expr . TIMES arith_expr
    (62) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 60 (arith_expr -> arith_expr MINUS arith_expr .)
    MINUS           reduce using rule 60 (arith_expr -> arith_expr MINUS arith_expr .)
    EQ              reduce using rule 60 (arith_expr -> arith_expr MINUS arith_expr .)
    NEQ             reduce using rule 60 (arith_expr -> arith_expr MINUS arith_expr .)
    GT              reduce using rule 60 (arith_expr -> arith_expr MINUS arith_expr .)
    LT              reduce using rule 60 (arith_expr -> arith_expr MINUS arith_expr .)
    SEMICOLON       reduce using rule 60 (arith_expr -> arith_expr MINUS arith_expr .)
    error           reduce using rule 60 (arith_expr -> arith_expr MINUS arith_expr .)
    RPAREN          reduce using rule 60 (arith_expr -> arith_expr MINUS arith_expr .)
    COMMA           reduce using rule 60 (arith_expr -> arith_expr MINUS arith_expr .)
    RBRACKET        reduce using rule 60 (arith_expr -> arith_expr MINUS arith_expr .)
    TIMES           shift and go to state 89
    DIV             shift and go to state 90

  ! TIMES           [ reduce using rule 60 (arith_expr -> arith_expr MINUS arith_expr .) ]
  ! DIV             [ reduce using rule 60 (arith_expr -> arith_expr MINUS arith_expr .) ]
  ! PLUS            [ shift and go to state 87 ]
  ! MINUS           [ shift and go to state 88 ]


state 119

    (61) arith_expr -> arith_expr TIMES arith_expr .
    (59) arith_expr -> arith_expr . PLUS arith_expr
    (60) arith_expr -> arith_expr . MINUS arith_expr
    (61) arith_expr -> arith_expr . TIMES arith_expr
    (62) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 61 (arith_expr -> arith_expr TIMES arith_expr .)
    MINUS           reduce using rule 61 (arith_expr -> arith_expr TIMES arith_expr .)
    TIMES           reduce using rule 61 (arith_expr -> arith_expr TIMES arith_expr .)
    DIV             reduce using rule 61 (arith_expr -> arith_expr TIMES arith_expr .)
    EQ              reduce using rule 61 (arith_expr -> arith_expr TIMES arith_expr .)
    NEQ             reduce using rule 61 (arith_expr -> arith_expr TIMES arith_expr .)
    GT              reduce using rule 61 (arith_expr -> arith_expr TIMES arith_expr .)
    LT              reduce using rule 61 (arith_expr -> arith_expr TIMES arith_expr .)
    SEMICOLON       reduce using rule 61 (arith_expr -> arith_expr TIMES arith_expr .)
    error           reduce using rule 61 (arith_expr -> arith_expr TIMES arith_expr .)
    RPAREN          reduce using rule 61 (arith_expr -> arith_expr TIMES arith_expr .)
    COMMA           reduce using rule 61 (arith_expr -> arith_expr TIMES arith_expr .)
    RBRACKET        reduce using rule 61 (arith_expr -> arith_expr TIMES arith_expr .)

  ! PLUS            [ shift and go to state 87 ]
  ! MINUS           [ shift and go to state 88 ]
  ! TIMES           [ shift and go to state 89 ]
  ! DIV             [ shift and go to state 90 ]


state 120

    (62) arith_expr -> arith_expr DIV arith_expr .
    (59) arith_expr -> arith_expr . PLUS arith_expr
    (60) arith_expr -> arith_expr . MINUS arith_expr
    (61) arith_expr -> arith_expr . TIMES arith_expr
    (62) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 62 (arith_expr -> arith_expr DIV arith_expr .)
    MINUS           reduce using rule 62 (arith_expr -> arith_expr DIV arith_expr .)
    TIMES           reduce using rule 62 (arith_expr -> arith_expr DIV arith_expr .)
    DIV             reduce using rule 62 (arith_expr -> arith_expr DIV arith_expr .)
    EQ              reduce using rule 62 (arith_expr -> arith_expr DIV arith_expr .)
    NEQ             reduce using rule 62 (arith_expr -> arith_expr DIV arith_expr .)
    GT              reduce using rule 62 (arith_expr -> arith_expr DIV arith_expr .)
    LT              reduce using rule 62 (arith_expr -> arith_expr DIV arith_expr .)
    SEMICOLON       reduce using rule 62 (arith_expr -> arith_expr DIV arith_expr .)
    error           reduce using rule 62 (arith_expr -> arith_expr DIV arith_expr .)
    RPAREN          reduce using rule 62 (arith_expr -> arith_expr DIV arith_expr .)
    COMMA           reduce using rule 62 (arith_expr -> arith_expr DIV arith_expr .)
    RBRACKET        reduce using rule 62 (arith_expr -> arith_expr DIV arith_expr .)

  ! PLUS            [ shift and go to state 87 ]
  ! MINUS           [ shift and go to state 88 ]
  ! TIMES           [ shift and go to state 89 ]
  ! DIV             [ shift and go to state 90 ]


state 121

    (45) expr -> TIMES ID EQUAL . expr
    (43) expr -> . ID EQUAL expr
    (44) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (45) expr -> . TIMES ID EQUAL expr
    (46) expr -> . incr_expr
    (47) expr -> . basic_expr
    (54) incr_expr -> . ID INCREMENT
    (55) incr_expr -> . INCREMENT ID
    (48) basic_expr -> . basic_expr compare arith_expr
    (49) basic_expr -> . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 132
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 122

    (48) basic_expr -> basic_expr compare arith_expr .
    (59) arith_expr -> arith_expr . PLUS arith_expr
    (60) arith_expr -> arith_expr . MINUS arith_expr
    (61) arith_expr -> arith_expr . TIMES arith_expr
    (62) arith_expr -> arith_expr . DIV arith_expr

    EQ              reduce using rule 48 (basic_expr -> basic_expr compare arith_expr .)
    NEQ             reduce using rule 48 (basic_expr -> basic_expr compare arith_expr .)
    GT              reduce using rule 48 (basic_expr -> basic_expr compare arith_expr .)
    LT              reduce using rule 48 (basic_expr -> basic_expr compare arith_expr .)
    SEMICOLON       reduce using rule 48 (basic_expr -> basic_expr compare arith_expr .)
    error           reduce using rule 48 (basic_expr -> basic_expr compare arith_expr .)
    RPAREN          reduce using rule 48 (basic_expr -> basic_expr compare arith_expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIV             shift and go to state 90


state 123

    (40) stmt_forloop -> FOR LPAREN expr . SEMICOLON expr SEMICOLON expr RPAREN stmt

    SEMICOLON       shift and go to state 133


state 124

    (41) stmt_return -> RETURN expr SEMICOLON .

    RBRACE          reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    IF              reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    PRINT           reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    ID              reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    TIMES           reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    INCREMENT       reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    INT             reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    VOID            reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    MINUS           reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    FNUM            reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    INUM            reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    ADDRESS         reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 41 (stmt_return -> RETURN expr SEMICOLON .)


state 125

    (16) mstmt -> IF LPAREN expr RPAREN . mstmt ELSE mstmt
    (18) umstmt -> IF LPAREN expr RPAREN . genstmt
    (19) umstmt -> IF LPAREN expr RPAREN . mstmt ELSE umstmt
    (16) mstmt -> . IF LPAREN expr RPAREN mstmt ELSE mstmt
    (17) mstmt -> . stmt
    (14) genstmt -> . mstmt
    (15) genstmt -> . umstmt
    (20) stmt -> . expr SEMICOLON
    (21) stmt -> . declaration SEMICOLON
    (22) stmt -> . stmt_block
    (23) stmt -> . stmt_forloop
    (24) stmt -> . stmt_return
    (25) stmt -> . SEMICOLON
    (26) stmt -> . expr error
    (27) stmt -> . PRINT LPAREN argument_list RPAREN
    (18) umstmt -> . IF LPAREN expr RPAREN genstmt
    (19) umstmt -> . IF LPAREN expr RPAREN mstmt ELSE umstmt
    (43) expr -> . ID EQUAL expr
    (44) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (45) expr -> . TIMES ID EQUAL expr
    (46) expr -> . incr_expr
    (47) expr -> . basic_expr
    (28) declaration -> . type id_list
    (29) declaration -> . type TIMES id_list
    (37) stmt_block -> . LBRACE stmt_list RBRACE
    (40) stmt_forloop -> . FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (41) stmt_return -> . RETURN expr SEMICOLON
    (42) stmt_return -> . RETURN SEMICOLON
    (54) incr_expr -> . ID INCREMENT
    (55) incr_expr -> . INCREMENT ID
    (48) basic_expr -> . basic_expr compare arith_expr
    (49) basic_expr -> . arith_expr
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . VOID
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    IF              shift and go to state 51
    SEMICOLON       shift and go to state 55
    PRINT           shift and go to state 60
    ID              shift and go to state 61
    TIMES           shift and go to state 63
    LBRACE          shift and go to state 40
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    INCREMENT       shift and go to state 69
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 53
    mstmt                          shift and go to state 134
    genstmt                        shift and go to state 135
    umstmt                         shift and go to state 50
    stmt                           shift and go to state 54
    declaration                    shift and go to state 56
    stmt_block                     shift and go to state 57
    stmt_forloop                   shift and go to state 58
    stmt_return                    shift and go to state 59
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65
    type                           shift and go to state 66

state 126

    (68) arith_expr -> ID LBRACKET arith_expr . RBRACKET
    (59) arith_expr -> arith_expr . PLUS arith_expr
    (60) arith_expr -> arith_expr . MINUS arith_expr
    (61) arith_expr -> arith_expr . TIMES arith_expr
    (62) arith_expr -> arith_expr . DIV arith_expr

    RBRACKET        shift and go to state 136
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIV             shift and go to state 90


state 127

    (27) stmt -> PRINT LPAREN argument_list RPAREN .

    RBRACE          reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    IF              reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    PRINT           reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    ID              reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    LBRACE          reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    FOR             reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    RETURN          reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    INCREMENT       reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    INT             reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    FLOAT           reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    VOID            reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    LPAREN          reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    FNUM            reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    INUM            reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    ADDRESS         reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)
    ELSE            reduce using rule 27 (stmt -> PRINT LPAREN argument_list RPAREN .)


state 128

    (72) argument_list -> argument_list COMMA . argument
    (73) argument -> . empty
    (74) argument -> . arith_expr
    (75) argument -> . LITERAL
    (76) argument -> . error
    (77) empty -> .
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

  ! shift/reduce conflict for error resolved as shift
    LITERAL         shift and go to state 112
    error           shift and go to state 113
    RPAREN          reduce using rule 77 (empty -> .)
    COMMA           reduce using rule 77 (empty -> .)
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 78
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 77
    ADDRESS         shift and go to state 73

  ! error           [ reduce using rule 77 (empty -> .) ]

    argument                       shift and go to state 137
    empty                          shift and go to state 110
    arith_expr                     shift and go to state 111

state 129

    (44) expr -> ID LBRACKET arith_expr RBRACKET . EQUAL expr
    (68) arith_expr -> ID LBRACKET arith_expr RBRACKET .

    EQUAL           shift and go to state 138
    PLUS            reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    MINUS           reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    TIMES           reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    DIV             reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    EQ              reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    NEQ             reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    GT              reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    LT              reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    SEMICOLON       reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    error           reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    RPAREN          reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)


state 130

    (69) arith_expr -> ID LPAREN argument_list RPAREN .

    PLUS            reduce using rule 69 (arith_expr -> ID LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 69 (arith_expr -> ID LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 69 (arith_expr -> ID LPAREN argument_list RPAREN .)
    DIV             reduce using rule 69 (arith_expr -> ID LPAREN argument_list RPAREN .)
    EQ              reduce using rule 69 (arith_expr -> ID LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 69 (arith_expr -> ID LPAREN argument_list RPAREN .)
    GT              reduce using rule 69 (arith_expr -> ID LPAREN argument_list RPAREN .)
    LT              reduce using rule 69 (arith_expr -> ID LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 69 (arith_expr -> ID LPAREN argument_list RPAREN .)
    error           reduce using rule 69 (arith_expr -> ID LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 69 (arith_expr -> ID LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 69 (arith_expr -> ID LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 69 (arith_expr -> ID LPAREN argument_list RPAREN .)


state 131

    (70) arith_expr -> ID LPAREN argument_list error .

    PLUS            reduce using rule 70 (arith_expr -> ID LPAREN argument_list error .)
    MINUS           reduce using rule 70 (arith_expr -> ID LPAREN argument_list error .)
    TIMES           reduce using rule 70 (arith_expr -> ID LPAREN argument_list error .)
    DIV             reduce using rule 70 (arith_expr -> ID LPAREN argument_list error .)
    EQ              reduce using rule 70 (arith_expr -> ID LPAREN argument_list error .)
    NEQ             reduce using rule 70 (arith_expr -> ID LPAREN argument_list error .)
    GT              reduce using rule 70 (arith_expr -> ID LPAREN argument_list error .)
    LT              reduce using rule 70 (arith_expr -> ID LPAREN argument_list error .)
    SEMICOLON       reduce using rule 70 (arith_expr -> ID LPAREN argument_list error .)
    error           reduce using rule 70 (arith_expr -> ID LPAREN argument_list error .)
    RPAREN          reduce using rule 70 (arith_expr -> ID LPAREN argument_list error .)
    COMMA           reduce using rule 70 (arith_expr -> ID LPAREN argument_list error .)
    RBRACKET        reduce using rule 70 (arith_expr -> ID LPAREN argument_list error .)


state 132

    (45) expr -> TIMES ID EQUAL expr .

    SEMICOLON       reduce using rule 45 (expr -> TIMES ID EQUAL expr .)
    error           reduce using rule 45 (expr -> TIMES ID EQUAL expr .)
    RPAREN          reduce using rule 45 (expr -> TIMES ID EQUAL expr .)


state 133

    (40) stmt_forloop -> FOR LPAREN expr SEMICOLON . expr SEMICOLON expr RPAREN stmt
    (43) expr -> . ID EQUAL expr
    (44) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (45) expr -> . TIMES ID EQUAL expr
    (46) expr -> . incr_expr
    (47) expr -> . basic_expr
    (54) incr_expr -> . ID INCREMENT
    (55) incr_expr -> . INCREMENT ID
    (48) basic_expr -> . basic_expr compare arith_expr
    (49) basic_expr -> . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 139
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 134

    (16) mstmt -> IF LPAREN expr RPAREN mstmt . ELSE mstmt
    (19) umstmt -> IF LPAREN expr RPAREN mstmt . ELSE umstmt
    (14) genstmt -> mstmt .

    ELSE            shift and go to state 140
    RBRACE          reduce using rule 14 (genstmt -> mstmt .)
    IF              reduce using rule 14 (genstmt -> mstmt .)
    SEMICOLON       reduce using rule 14 (genstmt -> mstmt .)
    PRINT           reduce using rule 14 (genstmt -> mstmt .)
    ID              reduce using rule 14 (genstmt -> mstmt .)
    TIMES           reduce using rule 14 (genstmt -> mstmt .)
    LBRACE          reduce using rule 14 (genstmt -> mstmt .)
    FOR             reduce using rule 14 (genstmt -> mstmt .)
    RETURN          reduce using rule 14 (genstmt -> mstmt .)
    INCREMENT       reduce using rule 14 (genstmt -> mstmt .)
    INT             reduce using rule 14 (genstmt -> mstmt .)
    FLOAT           reduce using rule 14 (genstmt -> mstmt .)
    VOID            reduce using rule 14 (genstmt -> mstmt .)
    MINUS           reduce using rule 14 (genstmt -> mstmt .)
    LPAREN          reduce using rule 14 (genstmt -> mstmt .)
    FNUM            reduce using rule 14 (genstmt -> mstmt .)
    INUM            reduce using rule 14 (genstmt -> mstmt .)
    ADDRESS         reduce using rule 14 (genstmt -> mstmt .)


state 135

    (18) umstmt -> IF LPAREN expr RPAREN genstmt .

    RBRACE          reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    IF              reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    SEMICOLON       reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    PRINT           reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    ID              reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    TIMES           reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    LBRACE          reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    FOR             reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    RETURN          reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    INCREMENT       reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    INT             reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    FLOAT           reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    VOID            reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    MINUS           reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    LPAREN          reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    FNUM            reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    INUM            reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    ADDRESS         reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)


state 136

    (68) arith_expr -> ID LBRACKET arith_expr RBRACKET .

    RPAREN          reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    PLUS            reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    MINUS           reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    TIMES           reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    DIV             reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    EQ              reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    NEQ             reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    GT              reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    LT              reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    SEMICOLON       reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    error           reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    COMMA           reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    RBRACKET        reduce using rule 68 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)


state 137

    (72) argument_list -> argument_list COMMA argument .

    RPAREN          reduce using rule 72 (argument_list -> argument_list COMMA argument .)
    COMMA           reduce using rule 72 (argument_list -> argument_list COMMA argument .)
    error           reduce using rule 72 (argument_list -> argument_list COMMA argument .)


state 138

    (44) expr -> ID LBRACKET arith_expr RBRACKET EQUAL . expr
    (43) expr -> . ID EQUAL expr
    (44) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (45) expr -> . TIMES ID EQUAL expr
    (46) expr -> . incr_expr
    (47) expr -> . basic_expr
    (54) incr_expr -> . ID INCREMENT
    (55) incr_expr -> . INCREMENT ID
    (48) basic_expr -> . basic_expr compare arith_expr
    (49) basic_expr -> . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 62
    expr                           shift and go to state 141
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 139

    (40) stmt_forloop -> FOR LPAREN expr SEMICOLON expr . SEMICOLON expr RPAREN stmt

    SEMICOLON       shift and go to state 142


state 140

    (16) mstmt -> IF LPAREN expr RPAREN mstmt ELSE . mstmt
    (19) umstmt -> IF LPAREN expr RPAREN mstmt ELSE . umstmt
    (16) mstmt -> . IF LPAREN expr RPAREN mstmt ELSE mstmt
    (17) mstmt -> . stmt
    (18) umstmt -> . IF LPAREN expr RPAREN genstmt
    (19) umstmt -> . IF LPAREN expr RPAREN mstmt ELSE umstmt
    (20) stmt -> . expr SEMICOLON
    (21) stmt -> . declaration SEMICOLON
    (22) stmt -> . stmt_block
    (23) stmt -> . stmt_forloop
    (24) stmt -> . stmt_return
    (25) stmt -> . SEMICOLON
    (26) stmt -> . expr error
    (27) stmt -> . PRINT LPAREN argument_list RPAREN
    (43) expr -> . ID EQUAL expr
    (44) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (45) expr -> . TIMES ID EQUAL expr
    (46) expr -> . incr_expr
    (47) expr -> . basic_expr
    (28) declaration -> . type id_list
    (29) declaration -> . type TIMES id_list
    (37) stmt_block -> . LBRACE stmt_list RBRACE
    (40) stmt_forloop -> . FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (41) stmt_return -> . RETURN expr SEMICOLON
    (42) stmt_return -> . RETURN SEMICOLON
    (54) incr_expr -> . ID INCREMENT
    (55) incr_expr -> . INCREMENT ID
    (48) basic_expr -> . basic_expr compare arith_expr
    (49) basic_expr -> . arith_expr
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . VOID
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    IF              shift and go to state 51
    SEMICOLON       shift and go to state 55
    PRINT           shift and go to state 60
    ID              shift and go to state 61
    TIMES           shift and go to state 63
    LBRACE          shift and go to state 40
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    INCREMENT       shift and go to state 69
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 53
    mstmt                          shift and go to state 143
    umstmt                         shift and go to state 144
    stmt                           shift and go to state 54
    declaration                    shift and go to state 56
    stmt_block                     shift and go to state 57
    stmt_forloop                   shift and go to state 58
    stmt_return                    shift and go to state 59
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65
    type                           shift and go to state 66

state 141

    (44) expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr .

    SEMICOLON       reduce using rule 44 (expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr .)
    error           reduce using rule 44 (expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr .)
    RPAREN          reduce using rule 44 (expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr .)


state 142

    (40) stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON . expr RPAREN stmt
    (43) expr -> . ID EQUAL expr
    (44) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (45) expr -> . TIMES ID EQUAL expr
    (46) expr -> . incr_expr
    (47) expr -> . basic_expr
    (54) incr_expr -> . ID INCREMENT
    (55) incr_expr -> . INCREMENT ID
    (48) basic_expr -> . basic_expr compare arith_expr
    (49) basic_expr -> . arith_expr
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 145
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 143

    (16) mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .

    RBRACE          reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    IF              reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    SEMICOLON       reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    PRINT           reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    ID              reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    TIMES           reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    LBRACE          reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    FOR             reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    RETURN          reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    INCREMENT       reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    INT             reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    FLOAT           reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    VOID            reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    MINUS           reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    LPAREN          reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    FNUM            reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    INUM            reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    ADDRESS         reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    ELSE            reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)


state 144

    (19) umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .

    RBRACE          reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    IF              reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    SEMICOLON       reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    PRINT           reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    ID              reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    TIMES           reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    LBRACE          reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    FOR             reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    RETURN          reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    INCREMENT       reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    INT             reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    FLOAT           reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    VOID            reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    MINUS           reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    LPAREN          reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    FNUM            reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    INUM            reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    ADDRESS         reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)


state 145

    (40) stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr . RPAREN stmt

    RPAREN          shift and go to state 146


state 146

    (40) stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN . stmt
    (20) stmt -> . expr SEMICOLON
    (21) stmt -> . declaration SEMICOLON
    (22) stmt -> . stmt_block
    (23) stmt -> . stmt_forloop
    (24) stmt -> . stmt_return
    (25) stmt -> . SEMICOLON
    (26) stmt -> . expr error
    (27) stmt -> . PRINT LPAREN argument_list RPAREN
    (43) expr -> . ID EQUAL expr
    (44) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (45) expr -> . TIMES ID EQUAL expr
    (46) expr -> . incr_expr
    (47) expr -> . basic_expr
    (28) declaration -> . type id_list
    (29) declaration -> . type TIMES id_list
    (37) stmt_block -> . LBRACE stmt_list RBRACE
    (40) stmt_forloop -> . FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (41) stmt_return -> . RETURN expr SEMICOLON
    (42) stmt_return -> . RETURN SEMICOLON
    (54) incr_expr -> . ID INCREMENT
    (55) incr_expr -> . INCREMENT ID
    (48) basic_expr -> . basic_expr compare arith_expr
    (49) basic_expr -> . arith_expr
    (34) type -> . INT
    (35) type -> . FLOAT
    (36) type -> . VOID
    (56) arith_expr -> . MINUS arith_expr
    (57) arith_expr -> . LPAREN arith_expr RPAREN
    (58) arith_expr -> . LPAREN error
    (59) arith_expr -> . arith_expr PLUS arith_expr
    (60) arith_expr -> . arith_expr MINUS arith_expr
    (61) arith_expr -> . arith_expr TIMES arith_expr
    (62) arith_expr -> . arith_expr DIV arith_expr
    (63) arith_expr -> . ID
    (64) arith_expr -> . FNUM
    (65) arith_expr -> . INUM
    (66) arith_expr -> . TIMES ID
    (67) arith_expr -> . ADDRESS ID
    (68) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (69) arith_expr -> . ID LPAREN argument_list RPAREN
    (70) arith_expr -> . ID LPAREN argument_list error

    SEMICOLON       shift and go to state 55
    PRINT           shift and go to state 60
    ID              shift and go to state 61
    TIMES           shift and go to state 63
    LBRACE          shift and go to state 40
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    INCREMENT       shift and go to state 69
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 53
    stmt                           shift and go to state 147
    declaration                    shift and go to state 56
    stmt_block                     shift and go to state 57
    stmt_forloop                   shift and go to state 58
    stmt_return                    shift and go to state 59
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65
    type                           shift and go to state 66

state 147

    (40) stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .

    RBRACE          reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    IF              reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    SEMICOLON       reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    PRINT           reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    ID              reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    TIMES           reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    LBRACE          reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    FOR             reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    RETURN          reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    INCREMENT       reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    INT             reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    FLOAT           reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    VOID            reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    MINUS           reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    LPAREN          reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    FNUM            reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    INUM            reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    ADDRESS         reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    ELSE            reduce using rule 40 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for error in state 86 resolved as shift
WARNING: shift/reduce conflict for error in state 128 resolved as shift
