Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COLON
    DOUBLEQUOTE
    ELSE_IF
    PERIOD
    POINTER
    QUOTE

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration_list
Rule 2     declaration_list -> declaration_list func_declaration
Rule 3     declaration_list -> declaration_list declaration
Rule 4     declaration_list -> empty
Rule 5     func_declaration -> type ID LPAREN params RPAREN stmt_block
Rule 6     func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block
Rule 7     func_declaration -> type MAIN LPAREN params RPAREN stmt_block
Rule 8     params -> VOID
Rule 9     params -> param_list
Rule 10    param_list -> param
Rule 11    param_list -> param_list COMMA param
Rule 12    param -> type ID
Rule 13    param -> type TIMES ID
Rule 14    genstmt -> mstmt
Rule 15    genstmt -> umstmt
Rule 16    mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt
Rule 17    mstmt -> stmt
Rule 18    umstmt -> IF LPAREN expr RPAREN genstmt
Rule 19    umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt
Rule 20    stmt -> expr SEMICOLON
Rule 21    stmt -> declaration SEMICOLON
Rule 22    stmt -> stmt_block
Rule 23    stmt -> stmt_forloop
Rule 24    stmt -> stmt_return
Rule 25    stmt -> SEMICOLON
Rule 26    stmt -> PRINT LPAREN argument_list RPAREN
Rule 27    declaration -> type id_list
Rule 28    declaration -> type TIMES id_list
Rule 29    id_list -> idbracket
Rule 30    id_list -> id_list COMMA idbracket
Rule 31    idbracket -> ID
Rule 32    idbracket -> ID LBRACKET INUM RBRACKET
Rule 33    type -> INT
Rule 34    type -> FLOAT
Rule 35    type -> VOID
Rule 36    stmt_block -> LBRACE stmt_list RBRACE
Rule 37    stmt_list -> stmt_list genstmt
Rule 38    stmt_list -> empty
Rule 39    stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
Rule 40    stmt_return -> RETURN expr SEMICOLON
Rule 41    stmt_return -> RETURN SEMICOLON
Rule 42    expr -> ID EQUAL expr
Rule 43    expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr
Rule 44    expr -> TIMES ID EQUAL expr
Rule 45    expr -> incr_expr
Rule 46    expr -> basic_expr
Rule 47    basic_expr -> basic_expr compare arith_expr
Rule 48    basic_expr -> arith_expr
Rule 49    compare -> EQ
Rule 50    compare -> NEQ
Rule 51    compare -> GT
Rule 52    compare -> LT
Rule 53    incr_expr -> ID INCREMENT
Rule 54    incr_expr -> INCREMENT ID
Rule 55    arith_expr -> MINUS arith_expr
Rule 56    arith_expr -> LPAREN arith_expr RPAREN
Rule 57    arith_expr -> arith_expr PLUS arith_expr
Rule 58    arith_expr -> arith_expr MINUS arith_expr
Rule 59    arith_expr -> arith_expr TIMES arith_expr
Rule 60    arith_expr -> arith_expr DIV arith_expr
Rule 61    arith_expr -> ID
Rule 62    arith_expr -> FNUM
Rule 63    arith_expr -> INUM
Rule 64    arith_expr -> TIMES ID
Rule 65    arith_expr -> ADDRESS ID
Rule 66    arith_expr -> ID LBRACKET arith_expr RBRACKET
Rule 67    arith_expr -> ID LPAREN argument_list RPAREN
Rule 68    argument_list -> argument
Rule 69    argument_list -> argument_list COMMA argument
Rule 70    argument -> empty
Rule 71    argument -> arith_expr
Rule 72    argument -> LITERAL
Rule 73    empty -> <empty>

Terminals, with rules where they appear

ADDRESS              : 65
COLON                : 
COMMA                : 11 30 69
DIV                  : 60
DOUBLEQUOTE          : 
ELSE                 : 16 19
ELSE_IF              : 
EQ                   : 49
EQUAL                : 42 43 44
FLOAT                : 34
FNUM                 : 62
FOR                  : 39
GT                   : 51
ID                   : 5 6 12 13 31 32 42 43 44 53 54 61 64 65 66 67
IF                   : 16 18 19
INCREMENT            : 53 54
INT                  : 33
INUM                 : 32 63
LBRACE               : 36
LBRACKET             : 32 43 66
LITERAL              : 72
LPAREN               : 5 6 7 16 18 19 26 39 56 67
LT                   : 52
MAIN                 : 7
MINUS                : 55 58
NEQ                  : 50
PERIOD               : 
PLUS                 : 57
POINTER              : 
PRINT                : 26
QUOTE                : 
RBRACE               : 36
RBRACKET             : 32 43 66
RETURN               : 40 41
RPAREN               : 5 6 7 16 18 19 26 39 56 67
SEMICOLON            : 20 21 25 39 39 40 41
TIMES                : 6 13 28 44 59 64
VOID                 : 8 35
error                : 

Nonterminals, with rules where they appear

argument             : 68 69
argument_list        : 26 67 69
arith_expr           : 43 47 48 55 56 57 57 58 58 59 59 60 60 66 71
basic_expr           : 46 47
compare              : 47
declaration          : 3 21
declaration_list     : 1 2 3
empty                : 4 38 70
expr                 : 16 18 19 20 39 39 39 40 42 43 44
func_declaration     : 2
genstmt              : 18 37
id_list              : 27 28 30
idbracket            : 29 30
incr_expr            : 45
mstmt                : 14 16 16 19
param                : 10 11
param_list           : 9 11
params               : 5 6 7
program              : 0
stmt                 : 17 39
stmt_block           : 5 6 7 22
stmt_forloop         : 23
stmt_list            : 36 37
stmt_return          : 24
type                 : 5 6 7 12 13 27 28
umstmt               : 15 19

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration_list
    (2) declaration_list -> . declaration_list func_declaration
    (3) declaration_list -> . declaration_list declaration
    (4) declaration_list -> . empty
    (73) empty -> .

    INT             reduce using rule 73 (empty -> .)
    FLOAT           reduce using rule 73 (empty -> .)
    VOID            reduce using rule 73 (empty -> .)
    $end            reduce using rule 73 (empty -> .)

    program                        shift and go to state 1
    declaration_list               shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> declaration_list .
    (2) declaration_list -> declaration_list . func_declaration
    (3) declaration_list -> declaration_list . declaration
    (5) func_declaration -> . type ID LPAREN params RPAREN stmt_block
    (6) func_declaration -> . type TIMES ID LPAREN params RPAREN stmt_block
    (7) func_declaration -> . type MAIN LPAREN params RPAREN stmt_block
    (27) declaration -> . type id_list
    (28) declaration -> . type TIMES id_list
    (33) type -> . INT
    (34) type -> . FLOAT
    (35) type -> . VOID

    $end            reduce using rule 1 (program -> declaration_list .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9

    func_declaration               shift and go to state 4
    declaration                    shift and go to state 5
    type                           shift and go to state 6

state 3

    (4) declaration_list -> empty .

    INT             reduce using rule 4 (declaration_list -> empty .)
    FLOAT           reduce using rule 4 (declaration_list -> empty .)
    VOID            reduce using rule 4 (declaration_list -> empty .)
    $end            reduce using rule 4 (declaration_list -> empty .)


state 4

    (2) declaration_list -> declaration_list func_declaration .

    INT             reduce using rule 2 (declaration_list -> declaration_list func_declaration .)
    FLOAT           reduce using rule 2 (declaration_list -> declaration_list func_declaration .)
    VOID            reduce using rule 2 (declaration_list -> declaration_list func_declaration .)
    $end            reduce using rule 2 (declaration_list -> declaration_list func_declaration .)


state 5

    (3) declaration_list -> declaration_list declaration .

    INT             reduce using rule 3 (declaration_list -> declaration_list declaration .)
    FLOAT           reduce using rule 3 (declaration_list -> declaration_list declaration .)
    VOID            reduce using rule 3 (declaration_list -> declaration_list declaration .)
    $end            reduce using rule 3 (declaration_list -> declaration_list declaration .)


state 6

    (5) func_declaration -> type . ID LPAREN params RPAREN stmt_block
    (6) func_declaration -> type . TIMES ID LPAREN params RPAREN stmt_block
    (7) func_declaration -> type . MAIN LPAREN params RPAREN stmt_block
    (27) declaration -> type . id_list
    (28) declaration -> type . TIMES id_list
    (29) id_list -> . idbracket
    (30) id_list -> . id_list COMMA idbracket
    (31) idbracket -> . ID
    (32) idbracket -> . ID LBRACKET INUM RBRACKET

    ID              shift and go to state 10
    TIMES           shift and go to state 11
    MAIN            shift and go to state 12

    id_list                        shift and go to state 13
    idbracket                      shift and go to state 14

state 7

    (33) type -> INT .

    ID              reduce using rule 33 (type -> INT .)
    TIMES           reduce using rule 33 (type -> INT .)
    MAIN            reduce using rule 33 (type -> INT .)


state 8

    (34) type -> FLOAT .

    ID              reduce using rule 34 (type -> FLOAT .)
    TIMES           reduce using rule 34 (type -> FLOAT .)
    MAIN            reduce using rule 34 (type -> FLOAT .)


state 9

    (35) type -> VOID .

    ID              reduce using rule 35 (type -> VOID .)
    TIMES           reduce using rule 35 (type -> VOID .)
    MAIN            reduce using rule 35 (type -> VOID .)


state 10

    (5) func_declaration -> type ID . LPAREN params RPAREN stmt_block
    (31) idbracket -> ID .
    (32) idbracket -> ID . LBRACKET INUM RBRACKET

    LPAREN          shift and go to state 15
    COMMA           reduce using rule 31 (idbracket -> ID .)
    INT             reduce using rule 31 (idbracket -> ID .)
    FLOAT           reduce using rule 31 (idbracket -> ID .)
    VOID            reduce using rule 31 (idbracket -> ID .)
    $end            reduce using rule 31 (idbracket -> ID .)
    LBRACKET        shift and go to state 16


state 11

    (6) func_declaration -> type TIMES . ID LPAREN params RPAREN stmt_block
    (28) declaration -> type TIMES . id_list
    (29) id_list -> . idbracket
    (30) id_list -> . id_list COMMA idbracket
    (31) idbracket -> . ID
    (32) idbracket -> . ID LBRACKET INUM RBRACKET

    ID              shift and go to state 17

    id_list                        shift and go to state 18
    idbracket                      shift and go to state 14

state 12

    (7) func_declaration -> type MAIN . LPAREN params RPAREN stmt_block

    LPAREN          shift and go to state 19


state 13

    (27) declaration -> type id_list .
    (30) id_list -> id_list . COMMA idbracket

    INT             reduce using rule 27 (declaration -> type id_list .)
    FLOAT           reduce using rule 27 (declaration -> type id_list .)
    VOID            reduce using rule 27 (declaration -> type id_list .)
    $end            reduce using rule 27 (declaration -> type id_list .)
    SEMICOLON       reduce using rule 27 (declaration -> type id_list .)
    COMMA           shift and go to state 20


state 14

    (29) id_list -> idbracket .

    COMMA           reduce using rule 29 (id_list -> idbracket .)
    INT             reduce using rule 29 (id_list -> idbracket .)
    FLOAT           reduce using rule 29 (id_list -> idbracket .)
    VOID            reduce using rule 29 (id_list -> idbracket .)
    $end            reduce using rule 29 (id_list -> idbracket .)
    SEMICOLON       reduce using rule 29 (id_list -> idbracket .)


state 15

    (5) func_declaration -> type ID LPAREN . params RPAREN stmt_block
    (8) params -> . VOID
    (9) params -> . param_list
    (10) param_list -> . param
    (11) param_list -> . param_list COMMA param
    (12) param -> . type ID
    (13) param -> . type TIMES ID
    (33) type -> . INT
    (34) type -> . FLOAT
    (35) type -> . VOID

    VOID            shift and go to state 23
    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    type                           shift and go to state 21
    params                         shift and go to state 22
    param_list                     shift and go to state 24
    param                          shift and go to state 25

state 16

    (32) idbracket -> ID LBRACKET . INUM RBRACKET

    INUM            shift and go to state 26


state 17

    (6) func_declaration -> type TIMES ID . LPAREN params RPAREN stmt_block
    (31) idbracket -> ID .
    (32) idbracket -> ID . LBRACKET INUM RBRACKET

    LPAREN          shift and go to state 27
    COMMA           reduce using rule 31 (idbracket -> ID .)
    INT             reduce using rule 31 (idbracket -> ID .)
    FLOAT           reduce using rule 31 (idbracket -> ID .)
    VOID            reduce using rule 31 (idbracket -> ID .)
    $end            reduce using rule 31 (idbracket -> ID .)
    LBRACKET        shift and go to state 16


state 18

    (28) declaration -> type TIMES id_list .
    (30) id_list -> id_list . COMMA idbracket

    INT             reduce using rule 28 (declaration -> type TIMES id_list .)
    FLOAT           reduce using rule 28 (declaration -> type TIMES id_list .)
    VOID            reduce using rule 28 (declaration -> type TIMES id_list .)
    $end            reduce using rule 28 (declaration -> type TIMES id_list .)
    SEMICOLON       reduce using rule 28 (declaration -> type TIMES id_list .)
    COMMA           shift and go to state 20


state 19

    (7) func_declaration -> type MAIN LPAREN . params RPAREN stmt_block
    (8) params -> . VOID
    (9) params -> . param_list
    (10) param_list -> . param
    (11) param_list -> . param_list COMMA param
    (12) param -> . type ID
    (13) param -> . type TIMES ID
    (33) type -> . INT
    (34) type -> . FLOAT
    (35) type -> . VOID

    VOID            shift and go to state 23
    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    type                           shift and go to state 21
    params                         shift and go to state 28
    param_list                     shift and go to state 24
    param                          shift and go to state 25

state 20

    (30) id_list -> id_list COMMA . idbracket
    (31) idbracket -> . ID
    (32) idbracket -> . ID LBRACKET INUM RBRACKET

    ID              shift and go to state 30

    idbracket                      shift and go to state 29

state 21

    (12) param -> type . ID
    (13) param -> type . TIMES ID

    ID              shift and go to state 31
    TIMES           shift and go to state 32


state 22

    (5) func_declaration -> type ID LPAREN params . RPAREN stmt_block

    RPAREN          shift and go to state 33


state 23

    (8) params -> VOID .
    (35) type -> VOID .

    RPAREN          reduce using rule 8 (params -> VOID .)
    ID              reduce using rule 35 (type -> VOID .)
    TIMES           reduce using rule 35 (type -> VOID .)


state 24

    (9) params -> param_list .
    (11) param_list -> param_list . COMMA param

    RPAREN          reduce using rule 9 (params -> param_list .)
    COMMA           shift and go to state 34


state 25

    (10) param_list -> param .

    COMMA           reduce using rule 10 (param_list -> param .)
    RPAREN          reduce using rule 10 (param_list -> param .)


state 26

    (32) idbracket -> ID LBRACKET INUM . RBRACKET

    RBRACKET        shift and go to state 35


state 27

    (6) func_declaration -> type TIMES ID LPAREN . params RPAREN stmt_block
    (8) params -> . VOID
    (9) params -> . param_list
    (10) param_list -> . param
    (11) param_list -> . param_list COMMA param
    (12) param -> . type ID
    (13) param -> . type TIMES ID
    (33) type -> . INT
    (34) type -> . FLOAT
    (35) type -> . VOID

    VOID            shift and go to state 23
    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    type                           shift and go to state 21
    params                         shift and go to state 36
    param_list                     shift and go to state 24
    param                          shift and go to state 25

state 28

    (7) func_declaration -> type MAIN LPAREN params . RPAREN stmt_block

    RPAREN          shift and go to state 37


state 29

    (30) id_list -> id_list COMMA idbracket .

    COMMA           reduce using rule 30 (id_list -> id_list COMMA idbracket .)
    INT             reduce using rule 30 (id_list -> id_list COMMA idbracket .)
    FLOAT           reduce using rule 30 (id_list -> id_list COMMA idbracket .)
    VOID            reduce using rule 30 (id_list -> id_list COMMA idbracket .)
    $end            reduce using rule 30 (id_list -> id_list COMMA idbracket .)
    SEMICOLON       reduce using rule 30 (id_list -> id_list COMMA idbracket .)


state 30

    (31) idbracket -> ID .
    (32) idbracket -> ID . LBRACKET INUM RBRACKET

    COMMA           reduce using rule 31 (idbracket -> ID .)
    INT             reduce using rule 31 (idbracket -> ID .)
    FLOAT           reduce using rule 31 (idbracket -> ID .)
    VOID            reduce using rule 31 (idbracket -> ID .)
    $end            reduce using rule 31 (idbracket -> ID .)
    SEMICOLON       reduce using rule 31 (idbracket -> ID .)
    LBRACKET        shift and go to state 16


state 31

    (12) param -> type ID .

    COMMA           reduce using rule 12 (param -> type ID .)
    RPAREN          reduce using rule 12 (param -> type ID .)


state 32

    (13) param -> type TIMES . ID

    ID              shift and go to state 38


state 33

    (5) func_declaration -> type ID LPAREN params RPAREN . stmt_block
    (36) stmt_block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 40

    stmt_block                     shift and go to state 39

state 34

    (11) param_list -> param_list COMMA . param
    (12) param -> . type ID
    (13) param -> . type TIMES ID
    (33) type -> . INT
    (34) type -> . FLOAT
    (35) type -> . VOID

    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9

    param                          shift and go to state 41
    type                           shift and go to state 21

state 35

    (32) idbracket -> ID LBRACKET INUM RBRACKET .

    COMMA           reduce using rule 32 (idbracket -> ID LBRACKET INUM RBRACKET .)
    INT             reduce using rule 32 (idbracket -> ID LBRACKET INUM RBRACKET .)
    FLOAT           reduce using rule 32 (idbracket -> ID LBRACKET INUM RBRACKET .)
    VOID            reduce using rule 32 (idbracket -> ID LBRACKET INUM RBRACKET .)
    $end            reduce using rule 32 (idbracket -> ID LBRACKET INUM RBRACKET .)
    SEMICOLON       reduce using rule 32 (idbracket -> ID LBRACKET INUM RBRACKET .)


state 36

    (6) func_declaration -> type TIMES ID LPAREN params . RPAREN stmt_block

    RPAREN          shift and go to state 42


state 37

    (7) func_declaration -> type MAIN LPAREN params RPAREN . stmt_block
    (36) stmt_block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 40

    stmt_block                     shift and go to state 43

state 38

    (13) param -> type TIMES ID .

    COMMA           reduce using rule 13 (param -> type TIMES ID .)
    RPAREN          reduce using rule 13 (param -> type TIMES ID .)


state 39

    (5) func_declaration -> type ID LPAREN params RPAREN stmt_block .

    INT             reduce using rule 5 (func_declaration -> type ID LPAREN params RPAREN stmt_block .)
    FLOAT           reduce using rule 5 (func_declaration -> type ID LPAREN params RPAREN stmt_block .)
    VOID            reduce using rule 5 (func_declaration -> type ID LPAREN params RPAREN stmt_block .)
    $end            reduce using rule 5 (func_declaration -> type ID LPAREN params RPAREN stmt_block .)


state 40

    (36) stmt_block -> LBRACE . stmt_list RBRACE
    (37) stmt_list -> . stmt_list genstmt
    (38) stmt_list -> . empty
    (73) empty -> .

    RBRACE          reduce using rule 73 (empty -> .)
    IF              reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    PRINT           reduce using rule 73 (empty -> .)
    ID              reduce using rule 73 (empty -> .)
    TIMES           reduce using rule 73 (empty -> .)
    LBRACE          reduce using rule 73 (empty -> .)
    FOR             reduce using rule 73 (empty -> .)
    RETURN          reduce using rule 73 (empty -> .)
    INCREMENT       reduce using rule 73 (empty -> .)
    INT             reduce using rule 73 (empty -> .)
    FLOAT           reduce using rule 73 (empty -> .)
    VOID            reduce using rule 73 (empty -> .)
    MINUS           reduce using rule 73 (empty -> .)
    LPAREN          reduce using rule 73 (empty -> .)
    FNUM            reduce using rule 73 (empty -> .)
    INUM            reduce using rule 73 (empty -> .)
    ADDRESS         reduce using rule 73 (empty -> .)

    stmt_list                      shift and go to state 44
    empty                          shift and go to state 45

state 41

    (11) param_list -> param_list COMMA param .

    COMMA           reduce using rule 11 (param_list -> param_list COMMA param .)
    RPAREN          reduce using rule 11 (param_list -> param_list COMMA param .)


state 42

    (6) func_declaration -> type TIMES ID LPAREN params RPAREN . stmt_block
    (36) stmt_block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 40

    stmt_block                     shift and go to state 46

state 43

    (7) func_declaration -> type MAIN LPAREN params RPAREN stmt_block .

    INT             reduce using rule 7 (func_declaration -> type MAIN LPAREN params RPAREN stmt_block .)
    FLOAT           reduce using rule 7 (func_declaration -> type MAIN LPAREN params RPAREN stmt_block .)
    VOID            reduce using rule 7 (func_declaration -> type MAIN LPAREN params RPAREN stmt_block .)
    $end            reduce using rule 7 (func_declaration -> type MAIN LPAREN params RPAREN stmt_block .)


state 44

    (36) stmt_block -> LBRACE stmt_list . RBRACE
    (37) stmt_list -> stmt_list . genstmt
    (14) genstmt -> . mstmt
    (15) genstmt -> . umstmt
    (16) mstmt -> . IF LPAREN expr RPAREN mstmt ELSE mstmt
    (17) mstmt -> . stmt
    (18) umstmt -> . IF LPAREN expr RPAREN genstmt
    (19) umstmt -> . IF LPAREN expr RPAREN mstmt ELSE umstmt
    (20) stmt -> . expr SEMICOLON
    (21) stmt -> . declaration SEMICOLON
    (22) stmt -> . stmt_block
    (23) stmt -> . stmt_forloop
    (24) stmt -> . stmt_return
    (25) stmt -> . SEMICOLON
    (26) stmt -> . PRINT LPAREN argument_list RPAREN
    (42) expr -> . ID EQUAL expr
    (43) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (44) expr -> . TIMES ID EQUAL expr
    (45) expr -> . incr_expr
    (46) expr -> . basic_expr
    (27) declaration -> . type id_list
    (28) declaration -> . type TIMES id_list
    (36) stmt_block -> . LBRACE stmt_list RBRACE
    (39) stmt_forloop -> . FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (40) stmt_return -> . RETURN expr SEMICOLON
    (41) stmt_return -> . RETURN SEMICOLON
    (53) incr_expr -> . ID INCREMENT
    (54) incr_expr -> . INCREMENT ID
    (47) basic_expr -> . basic_expr compare arith_expr
    (48) basic_expr -> . arith_expr
    (33) type -> . INT
    (34) type -> . FLOAT
    (35) type -> . VOID
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    RBRACE          shift and go to state 47
    IF              shift and go to state 51
    SEMICOLON       shift and go to state 55
    PRINT           shift and go to state 60
    ID              shift and go to state 61
    TIMES           shift and go to state 63
    LBRACE          shift and go to state 40
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    INCREMENT       shift and go to state 69
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    genstmt                        shift and go to state 48
    mstmt                          shift and go to state 49
    umstmt                         shift and go to state 50
    expr                           shift and go to state 53
    stmt                           shift and go to state 54
    declaration                    shift and go to state 56
    stmt_block                     shift and go to state 57
    stmt_forloop                   shift and go to state 58
    stmt_return                    shift and go to state 59
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65
    type                           shift and go to state 66

state 45

    (38) stmt_list -> empty .

    RBRACE          reduce using rule 38 (stmt_list -> empty .)
    IF              reduce using rule 38 (stmt_list -> empty .)
    SEMICOLON       reduce using rule 38 (stmt_list -> empty .)
    PRINT           reduce using rule 38 (stmt_list -> empty .)
    ID              reduce using rule 38 (stmt_list -> empty .)
    TIMES           reduce using rule 38 (stmt_list -> empty .)
    LBRACE          reduce using rule 38 (stmt_list -> empty .)
    FOR             reduce using rule 38 (stmt_list -> empty .)
    RETURN          reduce using rule 38 (stmt_list -> empty .)
    INCREMENT       reduce using rule 38 (stmt_list -> empty .)
    INT             reduce using rule 38 (stmt_list -> empty .)
    FLOAT           reduce using rule 38 (stmt_list -> empty .)
    VOID            reduce using rule 38 (stmt_list -> empty .)
    MINUS           reduce using rule 38 (stmt_list -> empty .)
    LPAREN          reduce using rule 38 (stmt_list -> empty .)
    FNUM            reduce using rule 38 (stmt_list -> empty .)
    INUM            reduce using rule 38 (stmt_list -> empty .)
    ADDRESS         reduce using rule 38 (stmt_list -> empty .)


state 46

    (6) func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .

    INT             reduce using rule 6 (func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .)
    FLOAT           reduce using rule 6 (func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .)
    VOID            reduce using rule 6 (func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .)
    $end            reduce using rule 6 (func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .)


state 47

    (36) stmt_block -> LBRACE stmt_list RBRACE .

    INT             reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    $end            reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    IF              reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    SEMICOLON       reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    PRINT           reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    ID              reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    TIMES           reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    LBRACE          reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    INCREMENT       reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    MINUS           reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    LPAREN          reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    FNUM            reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    INUM            reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    ADDRESS         reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)
    ELSE            reduce using rule 36 (stmt_block -> LBRACE stmt_list RBRACE .)


state 48

    (37) stmt_list -> stmt_list genstmt .

    RBRACE          reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    IF              reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    SEMICOLON       reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    PRINT           reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    ID              reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    TIMES           reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    LBRACE          reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    FOR             reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    RETURN          reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    INCREMENT       reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    INT             reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    FLOAT           reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    VOID            reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    MINUS           reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    LPAREN          reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    FNUM            reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    INUM            reduce using rule 37 (stmt_list -> stmt_list genstmt .)
    ADDRESS         reduce using rule 37 (stmt_list -> stmt_list genstmt .)


state 49

    (14) genstmt -> mstmt .

    RBRACE          reduce using rule 14 (genstmt -> mstmt .)
    IF              reduce using rule 14 (genstmt -> mstmt .)
    SEMICOLON       reduce using rule 14 (genstmt -> mstmt .)
    PRINT           reduce using rule 14 (genstmt -> mstmt .)
    ID              reduce using rule 14 (genstmt -> mstmt .)
    TIMES           reduce using rule 14 (genstmt -> mstmt .)
    LBRACE          reduce using rule 14 (genstmt -> mstmt .)
    FOR             reduce using rule 14 (genstmt -> mstmt .)
    RETURN          reduce using rule 14 (genstmt -> mstmt .)
    INCREMENT       reduce using rule 14 (genstmt -> mstmt .)
    INT             reduce using rule 14 (genstmt -> mstmt .)
    FLOAT           reduce using rule 14 (genstmt -> mstmt .)
    VOID            reduce using rule 14 (genstmt -> mstmt .)
    MINUS           reduce using rule 14 (genstmt -> mstmt .)
    LPAREN          reduce using rule 14 (genstmt -> mstmt .)
    FNUM            reduce using rule 14 (genstmt -> mstmt .)
    INUM            reduce using rule 14 (genstmt -> mstmt .)
    ADDRESS         reduce using rule 14 (genstmt -> mstmt .)


state 50

    (15) genstmt -> umstmt .

    RBRACE          reduce using rule 15 (genstmt -> umstmt .)
    IF              reduce using rule 15 (genstmt -> umstmt .)
    SEMICOLON       reduce using rule 15 (genstmt -> umstmt .)
    PRINT           reduce using rule 15 (genstmt -> umstmt .)
    ID              reduce using rule 15 (genstmt -> umstmt .)
    TIMES           reduce using rule 15 (genstmt -> umstmt .)
    LBRACE          reduce using rule 15 (genstmt -> umstmt .)
    FOR             reduce using rule 15 (genstmt -> umstmt .)
    RETURN          reduce using rule 15 (genstmt -> umstmt .)
    INCREMENT       reduce using rule 15 (genstmt -> umstmt .)
    INT             reduce using rule 15 (genstmt -> umstmt .)
    FLOAT           reduce using rule 15 (genstmt -> umstmt .)
    VOID            reduce using rule 15 (genstmt -> umstmt .)
    MINUS           reduce using rule 15 (genstmt -> umstmt .)
    LPAREN          reduce using rule 15 (genstmt -> umstmt .)
    FNUM            reduce using rule 15 (genstmt -> umstmt .)
    INUM            reduce using rule 15 (genstmt -> umstmt .)
    ADDRESS         reduce using rule 15 (genstmt -> umstmt .)


state 51

    (16) mstmt -> IF . LPAREN expr RPAREN mstmt ELSE mstmt
    (18) umstmt -> IF . LPAREN expr RPAREN genstmt
    (19) umstmt -> IF . LPAREN expr RPAREN mstmt ELSE umstmt

    LPAREN          shift and go to state 74


state 52

    (56) arith_expr -> LPAREN . arith_expr RPAREN
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 77
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 76
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 75

state 53

    (20) stmt -> expr . SEMICOLON

    SEMICOLON       shift and go to state 78


state 54

    (17) mstmt -> stmt .

    RBRACE          reduce using rule 17 (mstmt -> stmt .)
    IF              reduce using rule 17 (mstmt -> stmt .)
    SEMICOLON       reduce using rule 17 (mstmt -> stmt .)
    PRINT           reduce using rule 17 (mstmt -> stmt .)
    ID              reduce using rule 17 (mstmt -> stmt .)
    TIMES           reduce using rule 17 (mstmt -> stmt .)
    LBRACE          reduce using rule 17 (mstmt -> stmt .)
    FOR             reduce using rule 17 (mstmt -> stmt .)
    RETURN          reduce using rule 17 (mstmt -> stmt .)
    INCREMENT       reduce using rule 17 (mstmt -> stmt .)
    INT             reduce using rule 17 (mstmt -> stmt .)
    FLOAT           reduce using rule 17 (mstmt -> stmt .)
    VOID            reduce using rule 17 (mstmt -> stmt .)
    MINUS           reduce using rule 17 (mstmt -> stmt .)
    LPAREN          reduce using rule 17 (mstmt -> stmt .)
    FNUM            reduce using rule 17 (mstmt -> stmt .)
    INUM            reduce using rule 17 (mstmt -> stmt .)
    ADDRESS         reduce using rule 17 (mstmt -> stmt .)
    ELSE            reduce using rule 17 (mstmt -> stmt .)


state 55

    (25) stmt -> SEMICOLON .

    RBRACE          reduce using rule 25 (stmt -> SEMICOLON .)
    IF              reduce using rule 25 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 25 (stmt -> SEMICOLON .)
    PRINT           reduce using rule 25 (stmt -> SEMICOLON .)
    ID              reduce using rule 25 (stmt -> SEMICOLON .)
    TIMES           reduce using rule 25 (stmt -> SEMICOLON .)
    LBRACE          reduce using rule 25 (stmt -> SEMICOLON .)
    FOR             reduce using rule 25 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 25 (stmt -> SEMICOLON .)
    INCREMENT       reduce using rule 25 (stmt -> SEMICOLON .)
    INT             reduce using rule 25 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 25 (stmt -> SEMICOLON .)
    VOID            reduce using rule 25 (stmt -> SEMICOLON .)
    MINUS           reduce using rule 25 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 25 (stmt -> SEMICOLON .)
    FNUM            reduce using rule 25 (stmt -> SEMICOLON .)
    INUM            reduce using rule 25 (stmt -> SEMICOLON .)
    ADDRESS         reduce using rule 25 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 25 (stmt -> SEMICOLON .)


state 56

    (21) stmt -> declaration . SEMICOLON

    SEMICOLON       shift and go to state 79


state 57

    (22) stmt -> stmt_block .

    RBRACE          reduce using rule 22 (stmt -> stmt_block .)
    IF              reduce using rule 22 (stmt -> stmt_block .)
    SEMICOLON       reduce using rule 22 (stmt -> stmt_block .)
    PRINT           reduce using rule 22 (stmt -> stmt_block .)
    ID              reduce using rule 22 (stmt -> stmt_block .)
    TIMES           reduce using rule 22 (stmt -> stmt_block .)
    LBRACE          reduce using rule 22 (stmt -> stmt_block .)
    FOR             reduce using rule 22 (stmt -> stmt_block .)
    RETURN          reduce using rule 22 (stmt -> stmt_block .)
    INCREMENT       reduce using rule 22 (stmt -> stmt_block .)
    INT             reduce using rule 22 (stmt -> stmt_block .)
    FLOAT           reduce using rule 22 (stmt -> stmt_block .)
    VOID            reduce using rule 22 (stmt -> stmt_block .)
    MINUS           reduce using rule 22 (stmt -> stmt_block .)
    LPAREN          reduce using rule 22 (stmt -> stmt_block .)
    FNUM            reduce using rule 22 (stmt -> stmt_block .)
    INUM            reduce using rule 22 (stmt -> stmt_block .)
    ADDRESS         reduce using rule 22 (stmt -> stmt_block .)
    ELSE            reduce using rule 22 (stmt -> stmt_block .)


state 58

    (23) stmt -> stmt_forloop .

    RBRACE          reduce using rule 23 (stmt -> stmt_forloop .)
    IF              reduce using rule 23 (stmt -> stmt_forloop .)
    SEMICOLON       reduce using rule 23 (stmt -> stmt_forloop .)
    PRINT           reduce using rule 23 (stmt -> stmt_forloop .)
    ID              reduce using rule 23 (stmt -> stmt_forloop .)
    TIMES           reduce using rule 23 (stmt -> stmt_forloop .)
    LBRACE          reduce using rule 23 (stmt -> stmt_forloop .)
    FOR             reduce using rule 23 (stmt -> stmt_forloop .)
    RETURN          reduce using rule 23 (stmt -> stmt_forloop .)
    INCREMENT       reduce using rule 23 (stmt -> stmt_forloop .)
    INT             reduce using rule 23 (stmt -> stmt_forloop .)
    FLOAT           reduce using rule 23 (stmt -> stmt_forloop .)
    VOID            reduce using rule 23 (stmt -> stmt_forloop .)
    MINUS           reduce using rule 23 (stmt -> stmt_forloop .)
    LPAREN          reduce using rule 23 (stmt -> stmt_forloop .)
    FNUM            reduce using rule 23 (stmt -> stmt_forloop .)
    INUM            reduce using rule 23 (stmt -> stmt_forloop .)
    ADDRESS         reduce using rule 23 (stmt -> stmt_forloop .)
    ELSE            reduce using rule 23 (stmt -> stmt_forloop .)


state 59

    (24) stmt -> stmt_return .

    RBRACE          reduce using rule 24 (stmt -> stmt_return .)
    IF              reduce using rule 24 (stmt -> stmt_return .)
    SEMICOLON       reduce using rule 24 (stmt -> stmt_return .)
    PRINT           reduce using rule 24 (stmt -> stmt_return .)
    ID              reduce using rule 24 (stmt -> stmt_return .)
    TIMES           reduce using rule 24 (stmt -> stmt_return .)
    LBRACE          reduce using rule 24 (stmt -> stmt_return .)
    FOR             reduce using rule 24 (stmt -> stmt_return .)
    RETURN          reduce using rule 24 (stmt -> stmt_return .)
    INCREMENT       reduce using rule 24 (stmt -> stmt_return .)
    INT             reduce using rule 24 (stmt -> stmt_return .)
    FLOAT           reduce using rule 24 (stmt -> stmt_return .)
    VOID            reduce using rule 24 (stmt -> stmt_return .)
    MINUS           reduce using rule 24 (stmt -> stmt_return .)
    LPAREN          reduce using rule 24 (stmt -> stmt_return .)
    FNUM            reduce using rule 24 (stmt -> stmt_return .)
    INUM            reduce using rule 24 (stmt -> stmt_return .)
    ADDRESS         reduce using rule 24 (stmt -> stmt_return .)
    ELSE            reduce using rule 24 (stmt -> stmt_return .)


state 60

    (26) stmt -> PRINT . LPAREN argument_list RPAREN

    LPAREN          shift and go to state 80


state 61

    (42) expr -> ID . EQUAL expr
    (43) expr -> ID . LBRACKET arith_expr RBRACKET EQUAL expr
    (53) incr_expr -> ID . INCREMENT
    (61) arith_expr -> ID .
    (66) arith_expr -> ID . LBRACKET arith_expr RBRACKET
    (67) arith_expr -> ID . LPAREN argument_list RPAREN

    EQUAL           shift and go to state 81
    LBRACKET        shift and go to state 82
    INCREMENT       shift and go to state 83
    PLUS            reduce using rule 61 (arith_expr -> ID .)
    MINUS           reduce using rule 61 (arith_expr -> ID .)
    TIMES           reduce using rule 61 (arith_expr -> ID .)
    DIV             reduce using rule 61 (arith_expr -> ID .)
    EQ              reduce using rule 61 (arith_expr -> ID .)
    NEQ             reduce using rule 61 (arith_expr -> ID .)
    GT              reduce using rule 61 (arith_expr -> ID .)
    LT              reduce using rule 61 (arith_expr -> ID .)
    SEMICOLON       reduce using rule 61 (arith_expr -> ID .)
    RPAREN          reduce using rule 61 (arith_expr -> ID .)
    LPAREN          shift and go to state 84


state 62

    (48) basic_expr -> arith_expr .
    (57) arith_expr -> arith_expr . PLUS arith_expr
    (58) arith_expr -> arith_expr . MINUS arith_expr
    (59) arith_expr -> arith_expr . TIMES arith_expr
    (60) arith_expr -> arith_expr . DIV arith_expr

    EQ              reduce using rule 48 (basic_expr -> arith_expr .)
    NEQ             reduce using rule 48 (basic_expr -> arith_expr .)
    GT              reduce using rule 48 (basic_expr -> arith_expr .)
    LT              reduce using rule 48 (basic_expr -> arith_expr .)
    SEMICOLON       reduce using rule 48 (basic_expr -> arith_expr .)
    RPAREN          reduce using rule 48 (basic_expr -> arith_expr .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    TIMES           shift and go to state 87
    DIV             shift and go to state 88


state 63

    (44) expr -> TIMES . ID EQUAL expr
    (64) arith_expr -> TIMES . ID

    ID              shift and go to state 89


state 64

    (45) expr -> incr_expr .

    SEMICOLON       reduce using rule 45 (expr -> incr_expr .)
    RPAREN          reduce using rule 45 (expr -> incr_expr .)


state 65

    (46) expr -> basic_expr .
    (47) basic_expr -> basic_expr . compare arith_expr
    (49) compare -> . EQ
    (50) compare -> . NEQ
    (51) compare -> . GT
    (52) compare -> . LT

    SEMICOLON       reduce using rule 46 (expr -> basic_expr .)
    RPAREN          reduce using rule 46 (expr -> basic_expr .)
    EQ              shift and go to state 91
    NEQ             shift and go to state 92
    GT              shift and go to state 93
    LT              shift and go to state 94

    compare                        shift and go to state 90

state 66

    (27) declaration -> type . id_list
    (28) declaration -> type . TIMES id_list
    (29) id_list -> . idbracket
    (30) id_list -> . id_list COMMA idbracket
    (31) idbracket -> . ID
    (32) idbracket -> . ID LBRACKET INUM RBRACKET

    TIMES           shift and go to state 95
    ID              shift and go to state 30

    id_list                        shift and go to state 13
    idbracket                      shift and go to state 14

state 67

    (39) stmt_forloop -> FOR . LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt

    LPAREN          shift and go to state 96


state 68

    (40) stmt_return -> RETURN . expr SEMICOLON
    (41) stmt_return -> RETURN . SEMICOLON
    (42) expr -> . ID EQUAL expr
    (43) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (44) expr -> . TIMES ID EQUAL expr
    (45) expr -> . incr_expr
    (46) expr -> . basic_expr
    (53) incr_expr -> . ID INCREMENT
    (54) incr_expr -> . INCREMENT ID
    (47) basic_expr -> . basic_expr compare arith_expr
    (48) basic_expr -> . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    SEMICOLON       shift and go to state 98
    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 97
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 69

    (54) incr_expr -> INCREMENT . ID

    ID              shift and go to state 99


state 70

    (55) arith_expr -> MINUS . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 77
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 76
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 100

state 71

    (62) arith_expr -> FNUM .

    PLUS            reduce using rule 62 (arith_expr -> FNUM .)
    MINUS           reduce using rule 62 (arith_expr -> FNUM .)
    TIMES           reduce using rule 62 (arith_expr -> FNUM .)
    DIV             reduce using rule 62 (arith_expr -> FNUM .)
    EQ              reduce using rule 62 (arith_expr -> FNUM .)
    NEQ             reduce using rule 62 (arith_expr -> FNUM .)
    GT              reduce using rule 62 (arith_expr -> FNUM .)
    LT              reduce using rule 62 (arith_expr -> FNUM .)
    SEMICOLON       reduce using rule 62 (arith_expr -> FNUM .)
    RPAREN          reduce using rule 62 (arith_expr -> FNUM .)
    COMMA           reduce using rule 62 (arith_expr -> FNUM .)
    RBRACKET        reduce using rule 62 (arith_expr -> FNUM .)


state 72

    (63) arith_expr -> INUM .

    PLUS            reduce using rule 63 (arith_expr -> INUM .)
    MINUS           reduce using rule 63 (arith_expr -> INUM .)
    TIMES           reduce using rule 63 (arith_expr -> INUM .)
    DIV             reduce using rule 63 (arith_expr -> INUM .)
    EQ              reduce using rule 63 (arith_expr -> INUM .)
    NEQ             reduce using rule 63 (arith_expr -> INUM .)
    GT              reduce using rule 63 (arith_expr -> INUM .)
    LT              reduce using rule 63 (arith_expr -> INUM .)
    SEMICOLON       reduce using rule 63 (arith_expr -> INUM .)
    RPAREN          reduce using rule 63 (arith_expr -> INUM .)
    COMMA           reduce using rule 63 (arith_expr -> INUM .)
    RBRACKET        reduce using rule 63 (arith_expr -> INUM .)


state 73

    (65) arith_expr -> ADDRESS . ID

    ID              shift and go to state 101


state 74

    (16) mstmt -> IF LPAREN . expr RPAREN mstmt ELSE mstmt
    (18) umstmt -> IF LPAREN . expr RPAREN genstmt
    (19) umstmt -> IF LPAREN . expr RPAREN mstmt ELSE umstmt
    (42) expr -> . ID EQUAL expr
    (43) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (44) expr -> . TIMES ID EQUAL expr
    (45) expr -> . incr_expr
    (46) expr -> . basic_expr
    (53) incr_expr -> . ID INCREMENT
    (54) incr_expr -> . INCREMENT ID
    (47) basic_expr -> . basic_expr compare arith_expr
    (48) basic_expr -> . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 102
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 75

    (56) arith_expr -> LPAREN arith_expr . RPAREN
    (57) arith_expr -> arith_expr . PLUS arith_expr
    (58) arith_expr -> arith_expr . MINUS arith_expr
    (59) arith_expr -> arith_expr . TIMES arith_expr
    (60) arith_expr -> arith_expr . DIV arith_expr

    RPAREN          shift and go to state 103
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    TIMES           shift and go to state 87
    DIV             shift and go to state 88


state 76

    (64) arith_expr -> TIMES . ID

    ID              shift and go to state 104


state 77

    (61) arith_expr -> ID .
    (66) arith_expr -> ID . LBRACKET arith_expr RBRACKET
    (67) arith_expr -> ID . LPAREN argument_list RPAREN

    RPAREN          reduce using rule 61 (arith_expr -> ID .)
    PLUS            reduce using rule 61 (arith_expr -> ID .)
    MINUS           reduce using rule 61 (arith_expr -> ID .)
    TIMES           reduce using rule 61 (arith_expr -> ID .)
    DIV             reduce using rule 61 (arith_expr -> ID .)
    EQ              reduce using rule 61 (arith_expr -> ID .)
    NEQ             reduce using rule 61 (arith_expr -> ID .)
    GT              reduce using rule 61 (arith_expr -> ID .)
    LT              reduce using rule 61 (arith_expr -> ID .)
    SEMICOLON       reduce using rule 61 (arith_expr -> ID .)
    COMMA           reduce using rule 61 (arith_expr -> ID .)
    RBRACKET        reduce using rule 61 (arith_expr -> ID .)
    LBRACKET        shift and go to state 105
    LPAREN          shift and go to state 84


state 78

    (20) stmt -> expr SEMICOLON .

    RBRACE          reduce using rule 20 (stmt -> expr SEMICOLON .)
    IF              reduce using rule 20 (stmt -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 20 (stmt -> expr SEMICOLON .)
    PRINT           reduce using rule 20 (stmt -> expr SEMICOLON .)
    ID              reduce using rule 20 (stmt -> expr SEMICOLON .)
    TIMES           reduce using rule 20 (stmt -> expr SEMICOLON .)
    LBRACE          reduce using rule 20 (stmt -> expr SEMICOLON .)
    FOR             reduce using rule 20 (stmt -> expr SEMICOLON .)
    RETURN          reduce using rule 20 (stmt -> expr SEMICOLON .)
    INCREMENT       reduce using rule 20 (stmt -> expr SEMICOLON .)
    INT             reduce using rule 20 (stmt -> expr SEMICOLON .)
    FLOAT           reduce using rule 20 (stmt -> expr SEMICOLON .)
    VOID            reduce using rule 20 (stmt -> expr SEMICOLON .)
    MINUS           reduce using rule 20 (stmt -> expr SEMICOLON .)
    LPAREN          reduce using rule 20 (stmt -> expr SEMICOLON .)
    FNUM            reduce using rule 20 (stmt -> expr SEMICOLON .)
    INUM            reduce using rule 20 (stmt -> expr SEMICOLON .)
    ADDRESS         reduce using rule 20 (stmt -> expr SEMICOLON .)
    ELSE            reduce using rule 20 (stmt -> expr SEMICOLON .)


state 79

    (21) stmt -> declaration SEMICOLON .

    RBRACE          reduce using rule 21 (stmt -> declaration SEMICOLON .)
    IF              reduce using rule 21 (stmt -> declaration SEMICOLON .)
    SEMICOLON       reduce using rule 21 (stmt -> declaration SEMICOLON .)
    PRINT           reduce using rule 21 (stmt -> declaration SEMICOLON .)
    ID              reduce using rule 21 (stmt -> declaration SEMICOLON .)
    TIMES           reduce using rule 21 (stmt -> declaration SEMICOLON .)
    LBRACE          reduce using rule 21 (stmt -> declaration SEMICOLON .)
    FOR             reduce using rule 21 (stmt -> declaration SEMICOLON .)
    RETURN          reduce using rule 21 (stmt -> declaration SEMICOLON .)
    INCREMENT       reduce using rule 21 (stmt -> declaration SEMICOLON .)
    INT             reduce using rule 21 (stmt -> declaration SEMICOLON .)
    FLOAT           reduce using rule 21 (stmt -> declaration SEMICOLON .)
    VOID            reduce using rule 21 (stmt -> declaration SEMICOLON .)
    MINUS           reduce using rule 21 (stmt -> declaration SEMICOLON .)
    LPAREN          reduce using rule 21 (stmt -> declaration SEMICOLON .)
    FNUM            reduce using rule 21 (stmt -> declaration SEMICOLON .)
    INUM            reduce using rule 21 (stmt -> declaration SEMICOLON .)
    ADDRESS         reduce using rule 21 (stmt -> declaration SEMICOLON .)
    ELSE            reduce using rule 21 (stmt -> declaration SEMICOLON .)


state 80

    (26) stmt -> PRINT LPAREN . argument_list RPAREN
    (68) argument_list -> . argument
    (69) argument_list -> . argument_list COMMA argument
    (70) argument -> . empty
    (71) argument -> . arith_expr
    (72) argument -> . LITERAL
    (73) empty -> .
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    LITERAL         shift and go to state 110
    RPAREN          reduce using rule 73 (empty -> .)
    COMMA           reduce using rule 73 (empty -> .)
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 77
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 76
    ADDRESS         shift and go to state 73

    argument_list                  shift and go to state 106
    argument                       shift and go to state 107
    empty                          shift and go to state 108
    arith_expr                     shift and go to state 109

state 81

    (42) expr -> ID EQUAL . expr
    (42) expr -> . ID EQUAL expr
    (43) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (44) expr -> . TIMES ID EQUAL expr
    (45) expr -> . incr_expr
    (46) expr -> . basic_expr
    (53) incr_expr -> . ID INCREMENT
    (54) incr_expr -> . INCREMENT ID
    (47) basic_expr -> . basic_expr compare arith_expr
    (48) basic_expr -> . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 111
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 82

    (43) expr -> ID LBRACKET . arith_expr RBRACKET EQUAL expr
    (66) arith_expr -> ID LBRACKET . arith_expr RBRACKET
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 77
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 76
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 112

state 83

    (53) incr_expr -> ID INCREMENT .

    SEMICOLON       reduce using rule 53 (incr_expr -> ID INCREMENT .)
    RPAREN          reduce using rule 53 (incr_expr -> ID INCREMENT .)


state 84

    (67) arith_expr -> ID LPAREN . argument_list RPAREN
    (68) argument_list -> . argument
    (69) argument_list -> . argument_list COMMA argument
    (70) argument -> . empty
    (71) argument -> . arith_expr
    (72) argument -> . LITERAL
    (73) empty -> .
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    LITERAL         shift and go to state 110
    RPAREN          reduce using rule 73 (empty -> .)
    COMMA           reduce using rule 73 (empty -> .)
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 77
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 76
    ADDRESS         shift and go to state 73

    argument_list                  shift and go to state 113
    argument                       shift and go to state 107
    empty                          shift and go to state 108
    arith_expr                     shift and go to state 109

state 85

    (57) arith_expr -> arith_expr PLUS . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 77
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 76
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 114

state 86

    (58) arith_expr -> arith_expr MINUS . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 77
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 76
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 115

state 87

    (59) arith_expr -> arith_expr TIMES . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 77
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 76
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 116

state 88

    (60) arith_expr -> arith_expr DIV . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 77
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 76
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 117

state 89

    (44) expr -> TIMES ID . EQUAL expr
    (64) arith_expr -> TIMES ID .

    EQUAL           shift and go to state 118
    PLUS            reduce using rule 64 (arith_expr -> TIMES ID .)
    MINUS           reduce using rule 64 (arith_expr -> TIMES ID .)
    TIMES           reduce using rule 64 (arith_expr -> TIMES ID .)
    DIV             reduce using rule 64 (arith_expr -> TIMES ID .)
    EQ              reduce using rule 64 (arith_expr -> TIMES ID .)
    NEQ             reduce using rule 64 (arith_expr -> TIMES ID .)
    GT              reduce using rule 64 (arith_expr -> TIMES ID .)
    LT              reduce using rule 64 (arith_expr -> TIMES ID .)
    SEMICOLON       reduce using rule 64 (arith_expr -> TIMES ID .)
    RPAREN          reduce using rule 64 (arith_expr -> TIMES ID .)


state 90

    (47) basic_expr -> basic_expr compare . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 77
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 76
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 119

state 91

    (49) compare -> EQ .

    MINUS           reduce using rule 49 (compare -> EQ .)
    LPAREN          reduce using rule 49 (compare -> EQ .)
    ID              reduce using rule 49 (compare -> EQ .)
    FNUM            reduce using rule 49 (compare -> EQ .)
    INUM            reduce using rule 49 (compare -> EQ .)
    TIMES           reduce using rule 49 (compare -> EQ .)
    ADDRESS         reduce using rule 49 (compare -> EQ .)


state 92

    (50) compare -> NEQ .

    MINUS           reduce using rule 50 (compare -> NEQ .)
    LPAREN          reduce using rule 50 (compare -> NEQ .)
    ID              reduce using rule 50 (compare -> NEQ .)
    FNUM            reduce using rule 50 (compare -> NEQ .)
    INUM            reduce using rule 50 (compare -> NEQ .)
    TIMES           reduce using rule 50 (compare -> NEQ .)
    ADDRESS         reduce using rule 50 (compare -> NEQ .)


state 93

    (51) compare -> GT .

    MINUS           reduce using rule 51 (compare -> GT .)
    LPAREN          reduce using rule 51 (compare -> GT .)
    ID              reduce using rule 51 (compare -> GT .)
    FNUM            reduce using rule 51 (compare -> GT .)
    INUM            reduce using rule 51 (compare -> GT .)
    TIMES           reduce using rule 51 (compare -> GT .)
    ADDRESS         reduce using rule 51 (compare -> GT .)


state 94

    (52) compare -> LT .

    MINUS           reduce using rule 52 (compare -> LT .)
    LPAREN          reduce using rule 52 (compare -> LT .)
    ID              reduce using rule 52 (compare -> LT .)
    FNUM            reduce using rule 52 (compare -> LT .)
    INUM            reduce using rule 52 (compare -> LT .)
    TIMES           reduce using rule 52 (compare -> LT .)
    ADDRESS         reduce using rule 52 (compare -> LT .)


state 95

    (28) declaration -> type TIMES . id_list
    (29) id_list -> . idbracket
    (30) id_list -> . id_list COMMA idbracket
    (31) idbracket -> . ID
    (32) idbracket -> . ID LBRACKET INUM RBRACKET

    ID              shift and go to state 30

    id_list                        shift and go to state 18
    idbracket                      shift and go to state 14

state 96

    (39) stmt_forloop -> FOR LPAREN . expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (42) expr -> . ID EQUAL expr
    (43) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (44) expr -> . TIMES ID EQUAL expr
    (45) expr -> . incr_expr
    (46) expr -> . basic_expr
    (53) incr_expr -> . ID INCREMENT
    (54) incr_expr -> . INCREMENT ID
    (47) basic_expr -> . basic_expr compare arith_expr
    (48) basic_expr -> . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 120
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 97

    (40) stmt_return -> RETURN expr . SEMICOLON

    SEMICOLON       shift and go to state 121


state 98

    (41) stmt_return -> RETURN SEMICOLON .

    RBRACE          reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    IF              reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    PRINT           reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    ID              reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    TIMES           reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    FOR             reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    RETURN          reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    INCREMENT       reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    INT             reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    VOID            reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    MINUS           reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    FNUM            reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    INUM            reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    ADDRESS         reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)
    ELSE            reduce using rule 41 (stmt_return -> RETURN SEMICOLON .)


state 99

    (54) incr_expr -> INCREMENT ID .

    SEMICOLON       reduce using rule 54 (incr_expr -> INCREMENT ID .)
    RPAREN          reduce using rule 54 (incr_expr -> INCREMENT ID .)


state 100

    (55) arith_expr -> MINUS arith_expr .
    (57) arith_expr -> arith_expr . PLUS arith_expr
    (58) arith_expr -> arith_expr . MINUS arith_expr
    (59) arith_expr -> arith_expr . TIMES arith_expr
    (60) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 55 (arith_expr -> MINUS arith_expr .)
    MINUS           reduce using rule 55 (arith_expr -> MINUS arith_expr .)
    TIMES           reduce using rule 55 (arith_expr -> MINUS arith_expr .)
    DIV             reduce using rule 55 (arith_expr -> MINUS arith_expr .)
    EQ              reduce using rule 55 (arith_expr -> MINUS arith_expr .)
    NEQ             reduce using rule 55 (arith_expr -> MINUS arith_expr .)
    GT              reduce using rule 55 (arith_expr -> MINUS arith_expr .)
    LT              reduce using rule 55 (arith_expr -> MINUS arith_expr .)
    SEMICOLON       reduce using rule 55 (arith_expr -> MINUS arith_expr .)
    RPAREN          reduce using rule 55 (arith_expr -> MINUS arith_expr .)
    COMMA           reduce using rule 55 (arith_expr -> MINUS arith_expr .)
    RBRACKET        reduce using rule 55 (arith_expr -> MINUS arith_expr .)

  ! PLUS            [ shift and go to state 85 ]
  ! MINUS           [ shift and go to state 86 ]
  ! TIMES           [ shift and go to state 87 ]
  ! DIV             [ shift and go to state 88 ]


state 101

    (65) arith_expr -> ADDRESS ID .

    PLUS            reduce using rule 65 (arith_expr -> ADDRESS ID .)
    MINUS           reduce using rule 65 (arith_expr -> ADDRESS ID .)
    TIMES           reduce using rule 65 (arith_expr -> ADDRESS ID .)
    DIV             reduce using rule 65 (arith_expr -> ADDRESS ID .)
    EQ              reduce using rule 65 (arith_expr -> ADDRESS ID .)
    NEQ             reduce using rule 65 (arith_expr -> ADDRESS ID .)
    GT              reduce using rule 65 (arith_expr -> ADDRESS ID .)
    LT              reduce using rule 65 (arith_expr -> ADDRESS ID .)
    SEMICOLON       reduce using rule 65 (arith_expr -> ADDRESS ID .)
    RPAREN          reduce using rule 65 (arith_expr -> ADDRESS ID .)
    COMMA           reduce using rule 65 (arith_expr -> ADDRESS ID .)
    RBRACKET        reduce using rule 65 (arith_expr -> ADDRESS ID .)


state 102

    (16) mstmt -> IF LPAREN expr . RPAREN mstmt ELSE mstmt
    (18) umstmt -> IF LPAREN expr . RPAREN genstmt
    (19) umstmt -> IF LPAREN expr . RPAREN mstmt ELSE umstmt

    RPAREN          shift and go to state 122


state 103

    (56) arith_expr -> LPAREN arith_expr RPAREN .

    PLUS            reduce using rule 56 (arith_expr -> LPAREN arith_expr RPAREN .)
    MINUS           reduce using rule 56 (arith_expr -> LPAREN arith_expr RPAREN .)
    TIMES           reduce using rule 56 (arith_expr -> LPAREN arith_expr RPAREN .)
    DIV             reduce using rule 56 (arith_expr -> LPAREN arith_expr RPAREN .)
    EQ              reduce using rule 56 (arith_expr -> LPAREN arith_expr RPAREN .)
    NEQ             reduce using rule 56 (arith_expr -> LPAREN arith_expr RPAREN .)
    GT              reduce using rule 56 (arith_expr -> LPAREN arith_expr RPAREN .)
    LT              reduce using rule 56 (arith_expr -> LPAREN arith_expr RPAREN .)
    SEMICOLON       reduce using rule 56 (arith_expr -> LPAREN arith_expr RPAREN .)
    RPAREN          reduce using rule 56 (arith_expr -> LPAREN arith_expr RPAREN .)
    COMMA           reduce using rule 56 (arith_expr -> LPAREN arith_expr RPAREN .)
    RBRACKET        reduce using rule 56 (arith_expr -> LPAREN arith_expr RPAREN .)


state 104

    (64) arith_expr -> TIMES ID .

    RPAREN          reduce using rule 64 (arith_expr -> TIMES ID .)
    PLUS            reduce using rule 64 (arith_expr -> TIMES ID .)
    MINUS           reduce using rule 64 (arith_expr -> TIMES ID .)
    TIMES           reduce using rule 64 (arith_expr -> TIMES ID .)
    DIV             reduce using rule 64 (arith_expr -> TIMES ID .)
    EQ              reduce using rule 64 (arith_expr -> TIMES ID .)
    NEQ             reduce using rule 64 (arith_expr -> TIMES ID .)
    GT              reduce using rule 64 (arith_expr -> TIMES ID .)
    LT              reduce using rule 64 (arith_expr -> TIMES ID .)
    SEMICOLON       reduce using rule 64 (arith_expr -> TIMES ID .)
    COMMA           reduce using rule 64 (arith_expr -> TIMES ID .)
    RBRACKET        reduce using rule 64 (arith_expr -> TIMES ID .)


state 105

    (66) arith_expr -> ID LBRACKET . arith_expr RBRACKET
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 77
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 76
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 123

state 106

    (26) stmt -> PRINT LPAREN argument_list . RPAREN
    (69) argument_list -> argument_list . COMMA argument

    RPAREN          shift and go to state 124
    COMMA           shift and go to state 125


state 107

    (68) argument_list -> argument .

    RPAREN          reduce using rule 68 (argument_list -> argument .)
    COMMA           reduce using rule 68 (argument_list -> argument .)


state 108

    (70) argument -> empty .

    RPAREN          reduce using rule 70 (argument -> empty .)
    COMMA           reduce using rule 70 (argument -> empty .)


state 109

    (71) argument -> arith_expr .
    (57) arith_expr -> arith_expr . PLUS arith_expr
    (58) arith_expr -> arith_expr . MINUS arith_expr
    (59) arith_expr -> arith_expr . TIMES arith_expr
    (60) arith_expr -> arith_expr . DIV arith_expr

    RPAREN          reduce using rule 71 (argument -> arith_expr .)
    COMMA           reduce using rule 71 (argument -> arith_expr .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    TIMES           shift and go to state 87
    DIV             shift and go to state 88


state 110

    (72) argument -> LITERAL .

    RPAREN          reduce using rule 72 (argument -> LITERAL .)
    COMMA           reduce using rule 72 (argument -> LITERAL .)


state 111

    (42) expr -> ID EQUAL expr .

    SEMICOLON       reduce using rule 42 (expr -> ID EQUAL expr .)
    RPAREN          reduce using rule 42 (expr -> ID EQUAL expr .)


state 112

    (43) expr -> ID LBRACKET arith_expr . RBRACKET EQUAL expr
    (66) arith_expr -> ID LBRACKET arith_expr . RBRACKET
    (57) arith_expr -> arith_expr . PLUS arith_expr
    (58) arith_expr -> arith_expr . MINUS arith_expr
    (59) arith_expr -> arith_expr . TIMES arith_expr
    (60) arith_expr -> arith_expr . DIV arith_expr

    RBRACKET        shift and go to state 126
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    TIMES           shift and go to state 87
    DIV             shift and go to state 88


state 113

    (67) arith_expr -> ID LPAREN argument_list . RPAREN
    (69) argument_list -> argument_list . COMMA argument

    RPAREN          shift and go to state 127
    COMMA           shift and go to state 125


state 114

    (57) arith_expr -> arith_expr PLUS arith_expr .
    (57) arith_expr -> arith_expr . PLUS arith_expr
    (58) arith_expr -> arith_expr . MINUS arith_expr
    (59) arith_expr -> arith_expr . TIMES arith_expr
    (60) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 57 (arith_expr -> arith_expr PLUS arith_expr .)
    MINUS           reduce using rule 57 (arith_expr -> arith_expr PLUS arith_expr .)
    EQ              reduce using rule 57 (arith_expr -> arith_expr PLUS arith_expr .)
    NEQ             reduce using rule 57 (arith_expr -> arith_expr PLUS arith_expr .)
    GT              reduce using rule 57 (arith_expr -> arith_expr PLUS arith_expr .)
    LT              reduce using rule 57 (arith_expr -> arith_expr PLUS arith_expr .)
    SEMICOLON       reduce using rule 57 (arith_expr -> arith_expr PLUS arith_expr .)
    RPAREN          reduce using rule 57 (arith_expr -> arith_expr PLUS arith_expr .)
    COMMA           reduce using rule 57 (arith_expr -> arith_expr PLUS arith_expr .)
    RBRACKET        reduce using rule 57 (arith_expr -> arith_expr PLUS arith_expr .)
    TIMES           shift and go to state 87
    DIV             shift and go to state 88

  ! TIMES           [ reduce using rule 57 (arith_expr -> arith_expr PLUS arith_expr .) ]
  ! DIV             [ reduce using rule 57 (arith_expr -> arith_expr PLUS arith_expr .) ]
  ! PLUS            [ shift and go to state 85 ]
  ! MINUS           [ shift and go to state 86 ]


state 115

    (58) arith_expr -> arith_expr MINUS arith_expr .
    (57) arith_expr -> arith_expr . PLUS arith_expr
    (58) arith_expr -> arith_expr . MINUS arith_expr
    (59) arith_expr -> arith_expr . TIMES arith_expr
    (60) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 58 (arith_expr -> arith_expr MINUS arith_expr .)
    MINUS           reduce using rule 58 (arith_expr -> arith_expr MINUS arith_expr .)
    EQ              reduce using rule 58 (arith_expr -> arith_expr MINUS arith_expr .)
    NEQ             reduce using rule 58 (arith_expr -> arith_expr MINUS arith_expr .)
    GT              reduce using rule 58 (arith_expr -> arith_expr MINUS arith_expr .)
    LT              reduce using rule 58 (arith_expr -> arith_expr MINUS arith_expr .)
    SEMICOLON       reduce using rule 58 (arith_expr -> arith_expr MINUS arith_expr .)
    RPAREN          reduce using rule 58 (arith_expr -> arith_expr MINUS arith_expr .)
    COMMA           reduce using rule 58 (arith_expr -> arith_expr MINUS arith_expr .)
    RBRACKET        reduce using rule 58 (arith_expr -> arith_expr MINUS arith_expr .)
    TIMES           shift and go to state 87
    DIV             shift and go to state 88

  ! TIMES           [ reduce using rule 58 (arith_expr -> arith_expr MINUS arith_expr .) ]
  ! DIV             [ reduce using rule 58 (arith_expr -> arith_expr MINUS arith_expr .) ]
  ! PLUS            [ shift and go to state 85 ]
  ! MINUS           [ shift and go to state 86 ]


state 116

    (59) arith_expr -> arith_expr TIMES arith_expr .
    (57) arith_expr -> arith_expr . PLUS arith_expr
    (58) arith_expr -> arith_expr . MINUS arith_expr
    (59) arith_expr -> arith_expr . TIMES arith_expr
    (60) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 59 (arith_expr -> arith_expr TIMES arith_expr .)
    MINUS           reduce using rule 59 (arith_expr -> arith_expr TIMES arith_expr .)
    TIMES           reduce using rule 59 (arith_expr -> arith_expr TIMES arith_expr .)
    DIV             reduce using rule 59 (arith_expr -> arith_expr TIMES arith_expr .)
    EQ              reduce using rule 59 (arith_expr -> arith_expr TIMES arith_expr .)
    NEQ             reduce using rule 59 (arith_expr -> arith_expr TIMES arith_expr .)
    GT              reduce using rule 59 (arith_expr -> arith_expr TIMES arith_expr .)
    LT              reduce using rule 59 (arith_expr -> arith_expr TIMES arith_expr .)
    SEMICOLON       reduce using rule 59 (arith_expr -> arith_expr TIMES arith_expr .)
    RPAREN          reduce using rule 59 (arith_expr -> arith_expr TIMES arith_expr .)
    COMMA           reduce using rule 59 (arith_expr -> arith_expr TIMES arith_expr .)
    RBRACKET        reduce using rule 59 (arith_expr -> arith_expr TIMES arith_expr .)

  ! PLUS            [ shift and go to state 85 ]
  ! MINUS           [ shift and go to state 86 ]
  ! TIMES           [ shift and go to state 87 ]
  ! DIV             [ shift and go to state 88 ]


state 117

    (60) arith_expr -> arith_expr DIV arith_expr .
    (57) arith_expr -> arith_expr . PLUS arith_expr
    (58) arith_expr -> arith_expr . MINUS arith_expr
    (59) arith_expr -> arith_expr . TIMES arith_expr
    (60) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 60 (arith_expr -> arith_expr DIV arith_expr .)
    MINUS           reduce using rule 60 (arith_expr -> arith_expr DIV arith_expr .)
    TIMES           reduce using rule 60 (arith_expr -> arith_expr DIV arith_expr .)
    DIV             reduce using rule 60 (arith_expr -> arith_expr DIV arith_expr .)
    EQ              reduce using rule 60 (arith_expr -> arith_expr DIV arith_expr .)
    NEQ             reduce using rule 60 (arith_expr -> arith_expr DIV arith_expr .)
    GT              reduce using rule 60 (arith_expr -> arith_expr DIV arith_expr .)
    LT              reduce using rule 60 (arith_expr -> arith_expr DIV arith_expr .)
    SEMICOLON       reduce using rule 60 (arith_expr -> arith_expr DIV arith_expr .)
    RPAREN          reduce using rule 60 (arith_expr -> arith_expr DIV arith_expr .)
    COMMA           reduce using rule 60 (arith_expr -> arith_expr DIV arith_expr .)
    RBRACKET        reduce using rule 60 (arith_expr -> arith_expr DIV arith_expr .)

  ! PLUS            [ shift and go to state 85 ]
  ! MINUS           [ shift and go to state 86 ]
  ! TIMES           [ shift and go to state 87 ]
  ! DIV             [ shift and go to state 88 ]


state 118

    (44) expr -> TIMES ID EQUAL . expr
    (42) expr -> . ID EQUAL expr
    (43) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (44) expr -> . TIMES ID EQUAL expr
    (45) expr -> . incr_expr
    (46) expr -> . basic_expr
    (53) incr_expr -> . ID INCREMENT
    (54) incr_expr -> . INCREMENT ID
    (47) basic_expr -> . basic_expr compare arith_expr
    (48) basic_expr -> . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 128
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 119

    (47) basic_expr -> basic_expr compare arith_expr .
    (57) arith_expr -> arith_expr . PLUS arith_expr
    (58) arith_expr -> arith_expr . MINUS arith_expr
    (59) arith_expr -> arith_expr . TIMES arith_expr
    (60) arith_expr -> arith_expr . DIV arith_expr

    EQ              reduce using rule 47 (basic_expr -> basic_expr compare arith_expr .)
    NEQ             reduce using rule 47 (basic_expr -> basic_expr compare arith_expr .)
    GT              reduce using rule 47 (basic_expr -> basic_expr compare arith_expr .)
    LT              reduce using rule 47 (basic_expr -> basic_expr compare arith_expr .)
    SEMICOLON       reduce using rule 47 (basic_expr -> basic_expr compare arith_expr .)
    RPAREN          reduce using rule 47 (basic_expr -> basic_expr compare arith_expr .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    TIMES           shift and go to state 87
    DIV             shift and go to state 88


state 120

    (39) stmt_forloop -> FOR LPAREN expr . SEMICOLON expr SEMICOLON expr RPAREN stmt

    SEMICOLON       shift and go to state 129


state 121

    (40) stmt_return -> RETURN expr SEMICOLON .

    RBRACE          reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    IF              reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    PRINT           reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    ID              reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    TIMES           reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    INCREMENT       reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    INT             reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    VOID            reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    MINUS           reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    FNUM            reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    INUM            reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    ADDRESS         reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 40 (stmt_return -> RETURN expr SEMICOLON .)


state 122

    (16) mstmt -> IF LPAREN expr RPAREN . mstmt ELSE mstmt
    (18) umstmt -> IF LPAREN expr RPAREN . genstmt
    (19) umstmt -> IF LPAREN expr RPAREN . mstmt ELSE umstmt
    (16) mstmt -> . IF LPAREN expr RPAREN mstmt ELSE mstmt
    (17) mstmt -> . stmt
    (14) genstmt -> . mstmt
    (15) genstmt -> . umstmt
    (20) stmt -> . expr SEMICOLON
    (21) stmt -> . declaration SEMICOLON
    (22) stmt -> . stmt_block
    (23) stmt -> . stmt_forloop
    (24) stmt -> . stmt_return
    (25) stmt -> . SEMICOLON
    (26) stmt -> . PRINT LPAREN argument_list RPAREN
    (18) umstmt -> . IF LPAREN expr RPAREN genstmt
    (19) umstmt -> . IF LPAREN expr RPAREN mstmt ELSE umstmt
    (42) expr -> . ID EQUAL expr
    (43) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (44) expr -> . TIMES ID EQUAL expr
    (45) expr -> . incr_expr
    (46) expr -> . basic_expr
    (27) declaration -> . type id_list
    (28) declaration -> . type TIMES id_list
    (36) stmt_block -> . LBRACE stmt_list RBRACE
    (39) stmt_forloop -> . FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (40) stmt_return -> . RETURN expr SEMICOLON
    (41) stmt_return -> . RETURN SEMICOLON
    (53) incr_expr -> . ID INCREMENT
    (54) incr_expr -> . INCREMENT ID
    (47) basic_expr -> . basic_expr compare arith_expr
    (48) basic_expr -> . arith_expr
    (33) type -> . INT
    (34) type -> . FLOAT
    (35) type -> . VOID
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    IF              shift and go to state 51
    SEMICOLON       shift and go to state 55
    PRINT           shift and go to state 60
    ID              shift and go to state 61
    TIMES           shift and go to state 63
    LBRACE          shift and go to state 40
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    INCREMENT       shift and go to state 69
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 53
    mstmt                          shift and go to state 130
    genstmt                        shift and go to state 131
    umstmt                         shift and go to state 50
    stmt                           shift and go to state 54
    declaration                    shift and go to state 56
    stmt_block                     shift and go to state 57
    stmt_forloop                   shift and go to state 58
    stmt_return                    shift and go to state 59
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65
    type                           shift and go to state 66

state 123

    (66) arith_expr -> ID LBRACKET arith_expr . RBRACKET
    (57) arith_expr -> arith_expr . PLUS arith_expr
    (58) arith_expr -> arith_expr . MINUS arith_expr
    (59) arith_expr -> arith_expr . TIMES arith_expr
    (60) arith_expr -> arith_expr . DIV arith_expr

    RBRACKET        shift and go to state 132
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    TIMES           shift and go to state 87
    DIV             shift and go to state 88


state 124

    (26) stmt -> PRINT LPAREN argument_list RPAREN .

    RBRACE          reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    IF              reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    PRINT           reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    ID              reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    LBRACE          reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    FOR             reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    RETURN          reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    INCREMENT       reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    INT             reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    FLOAT           reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    VOID            reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    LPAREN          reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    FNUM            reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    INUM            reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    ADDRESS         reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)
    ELSE            reduce using rule 26 (stmt -> PRINT LPAREN argument_list RPAREN .)


state 125

    (69) argument_list -> argument_list COMMA . argument
    (70) argument -> . empty
    (71) argument -> . arith_expr
    (72) argument -> . LITERAL
    (73) empty -> .
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    LITERAL         shift and go to state 110
    RPAREN          reduce using rule 73 (empty -> .)
    COMMA           reduce using rule 73 (empty -> .)
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    ID              shift and go to state 77
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    TIMES           shift and go to state 76
    ADDRESS         shift and go to state 73

    argument                       shift and go to state 133
    empty                          shift and go to state 108
    arith_expr                     shift and go to state 109

state 126

    (43) expr -> ID LBRACKET arith_expr RBRACKET . EQUAL expr
    (66) arith_expr -> ID LBRACKET arith_expr RBRACKET .

    EQUAL           shift and go to state 134
    PLUS            reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    MINUS           reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    TIMES           reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    DIV             reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    EQ              reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    NEQ             reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    GT              reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    LT              reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    SEMICOLON       reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    RPAREN          reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)


state 127

    (67) arith_expr -> ID LPAREN argument_list RPAREN .

    PLUS            reduce using rule 67 (arith_expr -> ID LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 67 (arith_expr -> ID LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 67 (arith_expr -> ID LPAREN argument_list RPAREN .)
    DIV             reduce using rule 67 (arith_expr -> ID LPAREN argument_list RPAREN .)
    EQ              reduce using rule 67 (arith_expr -> ID LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 67 (arith_expr -> ID LPAREN argument_list RPAREN .)
    GT              reduce using rule 67 (arith_expr -> ID LPAREN argument_list RPAREN .)
    LT              reduce using rule 67 (arith_expr -> ID LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 67 (arith_expr -> ID LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 67 (arith_expr -> ID LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 67 (arith_expr -> ID LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 67 (arith_expr -> ID LPAREN argument_list RPAREN .)


state 128

    (44) expr -> TIMES ID EQUAL expr .

    SEMICOLON       reduce using rule 44 (expr -> TIMES ID EQUAL expr .)
    RPAREN          reduce using rule 44 (expr -> TIMES ID EQUAL expr .)


state 129

    (39) stmt_forloop -> FOR LPAREN expr SEMICOLON . expr SEMICOLON expr RPAREN stmt
    (42) expr -> . ID EQUAL expr
    (43) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (44) expr -> . TIMES ID EQUAL expr
    (45) expr -> . incr_expr
    (46) expr -> . basic_expr
    (53) incr_expr -> . ID INCREMENT
    (54) incr_expr -> . INCREMENT ID
    (47) basic_expr -> . basic_expr compare arith_expr
    (48) basic_expr -> . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 135
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 130

    (16) mstmt -> IF LPAREN expr RPAREN mstmt . ELSE mstmt
    (19) umstmt -> IF LPAREN expr RPAREN mstmt . ELSE umstmt
    (14) genstmt -> mstmt .

    ELSE            shift and go to state 136
    RBRACE          reduce using rule 14 (genstmt -> mstmt .)
    IF              reduce using rule 14 (genstmt -> mstmt .)
    SEMICOLON       reduce using rule 14 (genstmt -> mstmt .)
    PRINT           reduce using rule 14 (genstmt -> mstmt .)
    ID              reduce using rule 14 (genstmt -> mstmt .)
    TIMES           reduce using rule 14 (genstmt -> mstmt .)
    LBRACE          reduce using rule 14 (genstmt -> mstmt .)
    FOR             reduce using rule 14 (genstmt -> mstmt .)
    RETURN          reduce using rule 14 (genstmt -> mstmt .)
    INCREMENT       reduce using rule 14 (genstmt -> mstmt .)
    INT             reduce using rule 14 (genstmt -> mstmt .)
    FLOAT           reduce using rule 14 (genstmt -> mstmt .)
    VOID            reduce using rule 14 (genstmt -> mstmt .)
    MINUS           reduce using rule 14 (genstmt -> mstmt .)
    LPAREN          reduce using rule 14 (genstmt -> mstmt .)
    FNUM            reduce using rule 14 (genstmt -> mstmt .)
    INUM            reduce using rule 14 (genstmt -> mstmt .)
    ADDRESS         reduce using rule 14 (genstmt -> mstmt .)


state 131

    (18) umstmt -> IF LPAREN expr RPAREN genstmt .

    RBRACE          reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    IF              reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    SEMICOLON       reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    PRINT           reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    ID              reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    TIMES           reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    LBRACE          reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    FOR             reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    RETURN          reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    INCREMENT       reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    INT             reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    FLOAT           reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    VOID            reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    MINUS           reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    LPAREN          reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    FNUM            reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    INUM            reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    ADDRESS         reduce using rule 18 (umstmt -> IF LPAREN expr RPAREN genstmt .)


state 132

    (66) arith_expr -> ID LBRACKET arith_expr RBRACKET .

    RPAREN          reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    PLUS            reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    MINUS           reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    TIMES           reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    DIV             reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    EQ              reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    NEQ             reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    GT              reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    LT              reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    SEMICOLON       reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    COMMA           reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    RBRACKET        reduce using rule 66 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)


state 133

    (69) argument_list -> argument_list COMMA argument .

    RPAREN          reduce using rule 69 (argument_list -> argument_list COMMA argument .)
    COMMA           reduce using rule 69 (argument_list -> argument_list COMMA argument .)


state 134

    (43) expr -> ID LBRACKET arith_expr RBRACKET EQUAL . expr
    (42) expr -> . ID EQUAL expr
    (43) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (44) expr -> . TIMES ID EQUAL expr
    (45) expr -> . incr_expr
    (46) expr -> . basic_expr
    (53) incr_expr -> . ID INCREMENT
    (54) incr_expr -> . INCREMENT ID
    (47) basic_expr -> . basic_expr compare arith_expr
    (48) basic_expr -> . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    arith_expr                     shift and go to state 62
    expr                           shift and go to state 137
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 135

    (39) stmt_forloop -> FOR LPAREN expr SEMICOLON expr . SEMICOLON expr RPAREN stmt

    SEMICOLON       shift and go to state 138


state 136

    (16) mstmt -> IF LPAREN expr RPAREN mstmt ELSE . mstmt
    (19) umstmt -> IF LPAREN expr RPAREN mstmt ELSE . umstmt
    (16) mstmt -> . IF LPAREN expr RPAREN mstmt ELSE mstmt
    (17) mstmt -> . stmt
    (18) umstmt -> . IF LPAREN expr RPAREN genstmt
    (19) umstmt -> . IF LPAREN expr RPAREN mstmt ELSE umstmt
    (20) stmt -> . expr SEMICOLON
    (21) stmt -> . declaration SEMICOLON
    (22) stmt -> . stmt_block
    (23) stmt -> . stmt_forloop
    (24) stmt -> . stmt_return
    (25) stmt -> . SEMICOLON
    (26) stmt -> . PRINT LPAREN argument_list RPAREN
    (42) expr -> . ID EQUAL expr
    (43) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (44) expr -> . TIMES ID EQUAL expr
    (45) expr -> . incr_expr
    (46) expr -> . basic_expr
    (27) declaration -> . type id_list
    (28) declaration -> . type TIMES id_list
    (36) stmt_block -> . LBRACE stmt_list RBRACE
    (39) stmt_forloop -> . FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (40) stmt_return -> . RETURN expr SEMICOLON
    (41) stmt_return -> . RETURN SEMICOLON
    (53) incr_expr -> . ID INCREMENT
    (54) incr_expr -> . INCREMENT ID
    (47) basic_expr -> . basic_expr compare arith_expr
    (48) basic_expr -> . arith_expr
    (33) type -> . INT
    (34) type -> . FLOAT
    (35) type -> . VOID
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    IF              shift and go to state 51
    SEMICOLON       shift and go to state 55
    PRINT           shift and go to state 60
    ID              shift and go to state 61
    TIMES           shift and go to state 63
    LBRACE          shift and go to state 40
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    INCREMENT       shift and go to state 69
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 53
    mstmt                          shift and go to state 139
    umstmt                         shift and go to state 140
    stmt                           shift and go to state 54
    declaration                    shift and go to state 56
    stmt_block                     shift and go to state 57
    stmt_forloop                   shift and go to state 58
    stmt_return                    shift and go to state 59
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65
    type                           shift and go to state 66

state 137

    (43) expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr .

    SEMICOLON       reduce using rule 43 (expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr .)
    RPAREN          reduce using rule 43 (expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr .)


state 138

    (39) stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON . expr RPAREN stmt
    (42) expr -> . ID EQUAL expr
    (43) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (44) expr -> . TIMES ID EQUAL expr
    (45) expr -> . incr_expr
    (46) expr -> . basic_expr
    (53) incr_expr -> . ID INCREMENT
    (54) incr_expr -> . INCREMENT ID
    (47) basic_expr -> . basic_expr compare arith_expr
    (48) basic_expr -> . arith_expr
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 61
    TIMES           shift and go to state 63
    INCREMENT       shift and go to state 69
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 141
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65

state 139

    (16) mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .

    RBRACE          reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    IF              reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    SEMICOLON       reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    PRINT           reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    ID              reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    TIMES           reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    LBRACE          reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    FOR             reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    RETURN          reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    INCREMENT       reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    INT             reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    FLOAT           reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    VOID            reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    MINUS           reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    LPAREN          reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    FNUM            reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    INUM            reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    ADDRESS         reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    ELSE            reduce using rule 16 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)


state 140

    (19) umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .

    RBRACE          reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    IF              reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    SEMICOLON       reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    PRINT           reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    ID              reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    TIMES           reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    LBRACE          reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    FOR             reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    RETURN          reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    INCREMENT       reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    INT             reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    FLOAT           reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    VOID            reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    MINUS           reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    LPAREN          reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    FNUM            reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    INUM            reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    ADDRESS         reduce using rule 19 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)


state 141

    (39) stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr . RPAREN stmt

    RPAREN          shift and go to state 142


state 142

    (39) stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN . stmt
    (20) stmt -> . expr SEMICOLON
    (21) stmt -> . declaration SEMICOLON
    (22) stmt -> . stmt_block
    (23) stmt -> . stmt_forloop
    (24) stmt -> . stmt_return
    (25) stmt -> . SEMICOLON
    (26) stmt -> . PRINT LPAREN argument_list RPAREN
    (42) expr -> . ID EQUAL expr
    (43) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (44) expr -> . TIMES ID EQUAL expr
    (45) expr -> . incr_expr
    (46) expr -> . basic_expr
    (27) declaration -> . type id_list
    (28) declaration -> . type TIMES id_list
    (36) stmt_block -> . LBRACE stmt_list RBRACE
    (39) stmt_forloop -> . FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (40) stmt_return -> . RETURN expr SEMICOLON
    (41) stmt_return -> . RETURN SEMICOLON
    (53) incr_expr -> . ID INCREMENT
    (54) incr_expr -> . INCREMENT ID
    (47) basic_expr -> . basic_expr compare arith_expr
    (48) basic_expr -> . arith_expr
    (33) type -> . INT
    (34) type -> . FLOAT
    (35) type -> . VOID
    (55) arith_expr -> . MINUS arith_expr
    (56) arith_expr -> . LPAREN arith_expr RPAREN
    (57) arith_expr -> . arith_expr PLUS arith_expr
    (58) arith_expr -> . arith_expr MINUS arith_expr
    (59) arith_expr -> . arith_expr TIMES arith_expr
    (60) arith_expr -> . arith_expr DIV arith_expr
    (61) arith_expr -> . ID
    (62) arith_expr -> . FNUM
    (63) arith_expr -> . INUM
    (64) arith_expr -> . TIMES ID
    (65) arith_expr -> . ADDRESS ID
    (66) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (67) arith_expr -> . ID LPAREN argument_list RPAREN

    SEMICOLON       shift and go to state 55
    PRINT           shift and go to state 60
    ID              shift and go to state 61
    TIMES           shift and go to state 63
    LBRACE          shift and go to state 40
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    INCREMENT       shift and go to state 69
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 52
    FNUM            shift and go to state 71
    INUM            shift and go to state 72
    ADDRESS         shift and go to state 73

    expr                           shift and go to state 53
    stmt                           shift and go to state 143
    declaration                    shift and go to state 56
    stmt_block                     shift and go to state 57
    stmt_forloop                   shift and go to state 58
    stmt_return                    shift and go to state 59
    arith_expr                     shift and go to state 62
    incr_expr                      shift and go to state 64
    basic_expr                     shift and go to state 65
    type                           shift and go to state 66

state 143

    (39) stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .

    RBRACE          reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    IF              reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    SEMICOLON       reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    PRINT           reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    ID              reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    TIMES           reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    LBRACE          reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    FOR             reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    RETURN          reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    INCREMENT       reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    INT             reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    FLOAT           reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    VOID            reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    MINUS           reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    LPAREN          reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    FNUM            reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    INUM            reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    ADDRESS         reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    ELSE            reduce using rule 39 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)

