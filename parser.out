Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COLON
    DOUBLEQUOTE
    ELSE_IF
    PERIOD
    POINTER
    QUOTE

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration_list
Rule 2     declaration_list -> declaration_list func_declaration
Rule 3     declaration_list -> declaration_list declaration SEMICOLON
Rule 4     declaration_list -> empty
Rule 5     func_declaration -> type ID LPAREN params RPAREN stmt_block
Rule 6     func_declaration -> type ID LPAREN RPAREN stmt_block
Rule 7     func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block
Rule 8     func_declaration -> type TIMES ID LPAREN RPAREN stmt_block
Rule 9     func_declaration -> type MAIN LPAREN params RPAREN stmt_block
Rule 10    func_declaration -> type MAIN LPAREN RPAREN stmt_block
Rule 11    params -> VOID
Rule 12    params -> param_list
Rule 13    param_list -> param
Rule 14    param_list -> param_list COMMA param
Rule 15    param -> type ID
Rule 16    param -> type TIMES ID
Rule 17    genstmt -> mstmt
Rule 18    genstmt -> umstmt
Rule 19    mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt
Rule 20    mstmt -> stmt
Rule 21    umstmt -> IF LPAREN expr RPAREN genstmt
Rule 22    umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt
Rule 23    stmt -> expr SEMICOLON
Rule 24    stmt -> declaration SEMICOLON
Rule 25    stmt -> stmt_block
Rule 26    stmt -> stmt_forloop
Rule 27    stmt -> stmt_return
Rule 28    stmt -> SEMICOLON
Rule 29    stmt -> expr error
Rule 30    stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON
Rule 31    declaration -> declaration COMMA idbracket
Rule 32    declaration -> declaration COMMA TIMES idbracket
Rule 33    declaration -> type idbracket
Rule 34    declaration -> type TIMES idbracket
Rule 35    idbracket -> ID
Rule 36    idbracket -> ID LBRACKET INUM RBRACKET
Rule 37    type -> INT
Rule 38    type -> FLOAT
Rule 39    type -> VOID
Rule 40    stmt_block -> LBRACE stmt_list RBRACE
Rule 41    stmt_list -> stmt_list genstmt
Rule 42    stmt_list -> empty
Rule 43    stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
Rule 44    stmt_return -> RETURN expr SEMICOLON
Rule 45    stmt_return -> RETURN SEMICOLON
Rule 46    expr -> ID EQUAL expr
Rule 47    expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr
Rule 48    expr -> TIMES ID EQUAL expr
Rule 49    expr -> incr_expr
Rule 50    expr -> basic_expr
Rule 51    basic_expr -> basic_expr compare arith_expr
Rule 52    basic_expr -> arith_expr
Rule 53    compare -> EQ
Rule 54    compare -> NEQ
Rule 55    compare -> GT
Rule 56    compare -> LT
Rule 57    incr_expr -> ID INCREMENT
Rule 58    incr_expr -> INCREMENT ID
Rule 59    arith_expr -> MINUS arith_expr
Rule 60    arith_expr -> LPAREN arith_expr RPAREN
Rule 61    arith_expr -> arith_expr PLUS arith_expr
Rule 62    arith_expr -> arith_expr MINUS arith_expr
Rule 63    arith_expr -> arith_expr TIMES arith_expr
Rule 64    arith_expr -> arith_expr DIV arith_expr
Rule 65    arith_expr -> ID
Rule 66    arith_expr -> FNUM
Rule 67    arith_expr -> INUM
Rule 68    arith_expr -> TIMES ID
Rule 69    arith_expr -> TIMES LPAREN arith_expr RPAREN
Rule 70    arith_expr -> TIMES ID LPAREN argument_list RPAREN
Rule 71    arith_expr -> ADDRESS ID
Rule 72    arith_expr -> ID LBRACKET arith_expr RBRACKET
Rule 73    arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET
Rule 74    arith_expr -> ID LPAREN argument_list RPAREN
Rule 75    argument_list -> argument
Rule 76    argument_list -> argument_list COMMA argument
Rule 77    argument -> empty
Rule 78    argument -> arith_expr
Rule 79    argument -> LITERAL
Rule 80    argument -> error
Rule 81    empty -> <empty>

Terminals, with rules where they appear

ADDRESS              : 71
COLON                : 
COMMA                : 14 31 32 76
DIV                  : 64
DOUBLEQUOTE          : 
ELSE                 : 19 22
ELSE_IF              : 
EQ                   : 53
EQUAL                : 46 47 48
FLOAT                : 38
FNUM                 : 66
FOR                  : 43
GT                   : 55
ID                   : 5 6 7 8 15 16 35 36 46 47 48 57 58 65 68 70 71 72 73 74
IF                   : 19 21 22
INCREMENT            : 57 58
INT                  : 37
INUM                 : 36 67
LBRACE               : 40
LBRACKET             : 36 47 72 73
LITERAL              : 79
LPAREN               : 5 6 7 8 9 10 19 21 22 30 43 60 69 70 74
LT                   : 56
MAIN                 : 9 10
MINUS                : 59 62
NEQ                  : 54
PERIOD               : 
PLUS                 : 61
POINTER              : 
PRINT                : 30
QUOTE                : 
RBRACE               : 40
RBRACKET             : 36 47 72 73
RETURN               : 44 45
RPAREN               : 5 6 7 8 9 10 19 21 22 30 43 60 69 70 74
SEMICOLON            : 3 23 24 28 30 43 43 44 45
TIMES                : 7 8 16 32 34 48 63 68 69 70 73
VOID                 : 11 39
error                : 29 80

Nonterminals, with rules where they appear

argument             : 75 76
argument_list        : 30 70 74 76
arith_expr           : 47 51 52 59 60 61 61 62 62 63 63 64 64 69 72 73 78
basic_expr           : 50 51
compare              : 51
declaration          : 3 24 31 32
declaration_list     : 1 2 3
empty                : 4 42 77
expr                 : 19 21 22 23 29 43 43 43 44 46 47 48
func_declaration     : 2
genstmt              : 21 41
idbracket            : 31 32 33 34
incr_expr            : 49
mstmt                : 17 19 19 22
param                : 13 14
param_list           : 12 14
params               : 5 7 9
program              : 0
stmt                 : 20 43
stmt_block           : 5 6 7 8 9 10 25
stmt_forloop         : 26
stmt_list            : 40 41
stmt_return          : 27
type                 : 5 6 7 8 9 10 15 16 33 34
umstmt               : 18 22

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration_list
    (2) declaration_list -> . declaration_list func_declaration
    (3) declaration_list -> . declaration_list declaration SEMICOLON
    (4) declaration_list -> . empty
    (81) empty -> .

    INT             reduce using rule 81 (empty -> .)
    FLOAT           reduce using rule 81 (empty -> .)
    VOID            reduce using rule 81 (empty -> .)
    $end            reduce using rule 81 (empty -> .)

    program                        shift and go to state 1
    declaration_list               shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> declaration_list .
    (2) declaration_list -> declaration_list . func_declaration
    (3) declaration_list -> declaration_list . declaration SEMICOLON
    (5) func_declaration -> . type ID LPAREN params RPAREN stmt_block
    (6) func_declaration -> . type ID LPAREN RPAREN stmt_block
    (7) func_declaration -> . type TIMES ID LPAREN params RPAREN stmt_block
    (8) func_declaration -> . type TIMES ID LPAREN RPAREN stmt_block
    (9) func_declaration -> . type MAIN LPAREN params RPAREN stmt_block
    (10) func_declaration -> . type MAIN LPAREN RPAREN stmt_block
    (31) declaration -> . declaration COMMA idbracket
    (32) declaration -> . declaration COMMA TIMES idbracket
    (33) declaration -> . type idbracket
    (34) declaration -> . type TIMES idbracket
    (37) type -> . INT
    (38) type -> . FLOAT
    (39) type -> . VOID

    $end            reduce using rule 1 (program -> declaration_list .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9

    func_declaration               shift and go to state 4
    declaration                    shift and go to state 5
    type                           shift and go to state 6

state 3

    (4) declaration_list -> empty .

    INT             reduce using rule 4 (declaration_list -> empty .)
    FLOAT           reduce using rule 4 (declaration_list -> empty .)
    VOID            reduce using rule 4 (declaration_list -> empty .)
    $end            reduce using rule 4 (declaration_list -> empty .)


state 4

    (2) declaration_list -> declaration_list func_declaration .

    INT             reduce using rule 2 (declaration_list -> declaration_list func_declaration .)
    FLOAT           reduce using rule 2 (declaration_list -> declaration_list func_declaration .)
    VOID            reduce using rule 2 (declaration_list -> declaration_list func_declaration .)
    $end            reduce using rule 2 (declaration_list -> declaration_list func_declaration .)


state 5

    (3) declaration_list -> declaration_list declaration . SEMICOLON
    (31) declaration -> declaration . COMMA idbracket
    (32) declaration -> declaration . COMMA TIMES idbracket

    SEMICOLON       shift and go to state 10
    COMMA           shift and go to state 11


state 6

    (5) func_declaration -> type . ID LPAREN params RPAREN stmt_block
    (6) func_declaration -> type . ID LPAREN RPAREN stmt_block
    (7) func_declaration -> type . TIMES ID LPAREN params RPAREN stmt_block
    (8) func_declaration -> type . TIMES ID LPAREN RPAREN stmt_block
    (9) func_declaration -> type . MAIN LPAREN params RPAREN stmt_block
    (10) func_declaration -> type . MAIN LPAREN RPAREN stmt_block
    (33) declaration -> type . idbracket
    (34) declaration -> type . TIMES idbracket
    (35) idbracket -> . ID
    (36) idbracket -> . ID LBRACKET INUM RBRACKET

    ID              shift and go to state 12
    TIMES           shift and go to state 13
    MAIN            shift and go to state 14

    idbracket                      shift and go to state 15

state 7

    (37) type -> INT .

    ID              reduce using rule 37 (type -> INT .)
    TIMES           reduce using rule 37 (type -> INT .)
    MAIN            reduce using rule 37 (type -> INT .)


state 8

    (38) type -> FLOAT .

    ID              reduce using rule 38 (type -> FLOAT .)
    TIMES           reduce using rule 38 (type -> FLOAT .)
    MAIN            reduce using rule 38 (type -> FLOAT .)


state 9

    (39) type -> VOID .

    ID              reduce using rule 39 (type -> VOID .)
    TIMES           reduce using rule 39 (type -> VOID .)
    MAIN            reduce using rule 39 (type -> VOID .)


state 10

    (3) declaration_list -> declaration_list declaration SEMICOLON .

    INT             reduce using rule 3 (declaration_list -> declaration_list declaration SEMICOLON .)
    FLOAT           reduce using rule 3 (declaration_list -> declaration_list declaration SEMICOLON .)
    VOID            reduce using rule 3 (declaration_list -> declaration_list declaration SEMICOLON .)
    $end            reduce using rule 3 (declaration_list -> declaration_list declaration SEMICOLON .)


state 11

    (31) declaration -> declaration COMMA . idbracket
    (32) declaration -> declaration COMMA . TIMES idbracket
    (35) idbracket -> . ID
    (36) idbracket -> . ID LBRACKET INUM RBRACKET

    TIMES           shift and go to state 17
    ID              shift and go to state 18

    idbracket                      shift and go to state 16

state 12

    (5) func_declaration -> type ID . LPAREN params RPAREN stmt_block
    (6) func_declaration -> type ID . LPAREN RPAREN stmt_block
    (35) idbracket -> ID .
    (36) idbracket -> ID . LBRACKET INUM RBRACKET

    LPAREN          shift and go to state 19
    SEMICOLON       reduce using rule 35 (idbracket -> ID .)
    COMMA           reduce using rule 35 (idbracket -> ID .)
    LBRACKET        shift and go to state 20


state 13

    (7) func_declaration -> type TIMES . ID LPAREN params RPAREN stmt_block
    (8) func_declaration -> type TIMES . ID LPAREN RPAREN stmt_block
    (34) declaration -> type TIMES . idbracket
    (35) idbracket -> . ID
    (36) idbracket -> . ID LBRACKET INUM RBRACKET

    ID              shift and go to state 21

    idbracket                      shift and go to state 22

state 14

    (9) func_declaration -> type MAIN . LPAREN params RPAREN stmt_block
    (10) func_declaration -> type MAIN . LPAREN RPAREN stmt_block

    LPAREN          shift and go to state 23


state 15

    (33) declaration -> type idbracket .

    SEMICOLON       reduce using rule 33 (declaration -> type idbracket .)
    COMMA           reduce using rule 33 (declaration -> type idbracket .)


state 16

    (31) declaration -> declaration COMMA idbracket .

    SEMICOLON       reduce using rule 31 (declaration -> declaration COMMA idbracket .)
    COMMA           reduce using rule 31 (declaration -> declaration COMMA idbracket .)


state 17

    (32) declaration -> declaration COMMA TIMES . idbracket
    (35) idbracket -> . ID
    (36) idbracket -> . ID LBRACKET INUM RBRACKET

    ID              shift and go to state 18

    idbracket                      shift and go to state 24

state 18

    (35) idbracket -> ID .
    (36) idbracket -> ID . LBRACKET INUM RBRACKET

    SEMICOLON       reduce using rule 35 (idbracket -> ID .)
    COMMA           reduce using rule 35 (idbracket -> ID .)
    LBRACKET        shift and go to state 20


state 19

    (5) func_declaration -> type ID LPAREN . params RPAREN stmt_block
    (6) func_declaration -> type ID LPAREN . RPAREN stmt_block
    (11) params -> . VOID
    (12) params -> . param_list
    (13) param_list -> . param
    (14) param_list -> . param_list COMMA param
    (15) param -> . type ID
    (16) param -> . type TIMES ID
    (37) type -> . INT
    (38) type -> . FLOAT
    (39) type -> . VOID

    RPAREN          shift and go to state 27
    VOID            shift and go to state 28
    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    type                           shift and go to state 25
    params                         shift and go to state 26
    param_list                     shift and go to state 29
    param                          shift and go to state 30

state 20

    (36) idbracket -> ID LBRACKET . INUM RBRACKET

    INUM            shift and go to state 31


state 21

    (7) func_declaration -> type TIMES ID . LPAREN params RPAREN stmt_block
    (8) func_declaration -> type TIMES ID . LPAREN RPAREN stmt_block
    (35) idbracket -> ID .
    (36) idbracket -> ID . LBRACKET INUM RBRACKET

    LPAREN          shift and go to state 32
    SEMICOLON       reduce using rule 35 (idbracket -> ID .)
    COMMA           reduce using rule 35 (idbracket -> ID .)
    LBRACKET        shift and go to state 20


state 22

    (34) declaration -> type TIMES idbracket .

    SEMICOLON       reduce using rule 34 (declaration -> type TIMES idbracket .)
    COMMA           reduce using rule 34 (declaration -> type TIMES idbracket .)


state 23

    (9) func_declaration -> type MAIN LPAREN . params RPAREN stmt_block
    (10) func_declaration -> type MAIN LPAREN . RPAREN stmt_block
    (11) params -> . VOID
    (12) params -> . param_list
    (13) param_list -> . param
    (14) param_list -> . param_list COMMA param
    (15) param -> . type ID
    (16) param -> . type TIMES ID
    (37) type -> . INT
    (38) type -> . FLOAT
    (39) type -> . VOID

    RPAREN          shift and go to state 34
    VOID            shift and go to state 28
    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    type                           shift and go to state 25
    params                         shift and go to state 33
    param_list                     shift and go to state 29
    param                          shift and go to state 30

state 24

    (32) declaration -> declaration COMMA TIMES idbracket .

    SEMICOLON       reduce using rule 32 (declaration -> declaration COMMA TIMES idbracket .)
    COMMA           reduce using rule 32 (declaration -> declaration COMMA TIMES idbracket .)


state 25

    (15) param -> type . ID
    (16) param -> type . TIMES ID

    ID              shift and go to state 35
    TIMES           shift and go to state 36


state 26

    (5) func_declaration -> type ID LPAREN params . RPAREN stmt_block

    RPAREN          shift and go to state 37


state 27

    (6) func_declaration -> type ID LPAREN RPAREN . stmt_block
    (40) stmt_block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 39

    stmt_block                     shift and go to state 38

state 28

    (11) params -> VOID .
    (39) type -> VOID .

    RPAREN          reduce using rule 11 (params -> VOID .)
    ID              reduce using rule 39 (type -> VOID .)
    TIMES           reduce using rule 39 (type -> VOID .)


state 29

    (12) params -> param_list .
    (14) param_list -> param_list . COMMA param

    RPAREN          reduce using rule 12 (params -> param_list .)
    COMMA           shift and go to state 40


state 30

    (13) param_list -> param .

    COMMA           reduce using rule 13 (param_list -> param .)
    RPAREN          reduce using rule 13 (param_list -> param .)


state 31

    (36) idbracket -> ID LBRACKET INUM . RBRACKET

    RBRACKET        shift and go to state 41


state 32

    (7) func_declaration -> type TIMES ID LPAREN . params RPAREN stmt_block
    (8) func_declaration -> type TIMES ID LPAREN . RPAREN stmt_block
    (11) params -> . VOID
    (12) params -> . param_list
    (13) param_list -> . param
    (14) param_list -> . param_list COMMA param
    (15) param -> . type ID
    (16) param -> . type TIMES ID
    (37) type -> . INT
    (38) type -> . FLOAT
    (39) type -> . VOID

    RPAREN          shift and go to state 43
    VOID            shift and go to state 28
    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    type                           shift and go to state 25
    params                         shift and go to state 42
    param_list                     shift and go to state 29
    param                          shift and go to state 30

state 33

    (9) func_declaration -> type MAIN LPAREN params . RPAREN stmt_block

    RPAREN          shift and go to state 44


state 34

    (10) func_declaration -> type MAIN LPAREN RPAREN . stmt_block
    (40) stmt_block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 39

    stmt_block                     shift and go to state 45

state 35

    (15) param -> type ID .

    COMMA           reduce using rule 15 (param -> type ID .)
    RPAREN          reduce using rule 15 (param -> type ID .)


state 36

    (16) param -> type TIMES . ID

    ID              shift and go to state 46


state 37

    (5) func_declaration -> type ID LPAREN params RPAREN . stmt_block
    (40) stmt_block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 39

    stmt_block                     shift and go to state 47

state 38

    (6) func_declaration -> type ID LPAREN RPAREN stmt_block .

    INT             reduce using rule 6 (func_declaration -> type ID LPAREN RPAREN stmt_block .)
    FLOAT           reduce using rule 6 (func_declaration -> type ID LPAREN RPAREN stmt_block .)
    VOID            reduce using rule 6 (func_declaration -> type ID LPAREN RPAREN stmt_block .)
    $end            reduce using rule 6 (func_declaration -> type ID LPAREN RPAREN stmt_block .)


state 39

    (40) stmt_block -> LBRACE . stmt_list RBRACE
    (41) stmt_list -> . stmt_list genstmt
    (42) stmt_list -> . empty
    (81) empty -> .

    RBRACE          reduce using rule 81 (empty -> .)
    IF              reduce using rule 81 (empty -> .)
    SEMICOLON       reduce using rule 81 (empty -> .)
    PRINT           reduce using rule 81 (empty -> .)
    ID              reduce using rule 81 (empty -> .)
    TIMES           reduce using rule 81 (empty -> .)
    LBRACE          reduce using rule 81 (empty -> .)
    FOR             reduce using rule 81 (empty -> .)
    RETURN          reduce using rule 81 (empty -> .)
    INCREMENT       reduce using rule 81 (empty -> .)
    INT             reduce using rule 81 (empty -> .)
    FLOAT           reduce using rule 81 (empty -> .)
    VOID            reduce using rule 81 (empty -> .)
    MINUS           reduce using rule 81 (empty -> .)
    LPAREN          reduce using rule 81 (empty -> .)
    FNUM            reduce using rule 81 (empty -> .)
    INUM            reduce using rule 81 (empty -> .)
    ADDRESS         reduce using rule 81 (empty -> .)

    stmt_list                      shift and go to state 48
    empty                          shift and go to state 49

state 40

    (14) param_list -> param_list COMMA . param
    (15) param -> . type ID
    (16) param -> . type TIMES ID
    (37) type -> . INT
    (38) type -> . FLOAT
    (39) type -> . VOID

    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9

    param                          shift and go to state 50
    type                           shift and go to state 25

state 41

    (36) idbracket -> ID LBRACKET INUM RBRACKET .

    SEMICOLON       reduce using rule 36 (idbracket -> ID LBRACKET INUM RBRACKET .)
    COMMA           reduce using rule 36 (idbracket -> ID LBRACKET INUM RBRACKET .)


state 42

    (7) func_declaration -> type TIMES ID LPAREN params . RPAREN stmt_block

    RPAREN          shift and go to state 51


state 43

    (8) func_declaration -> type TIMES ID LPAREN RPAREN . stmt_block
    (40) stmt_block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 39

    stmt_block                     shift and go to state 52

state 44

    (9) func_declaration -> type MAIN LPAREN params RPAREN . stmt_block
    (40) stmt_block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 39

    stmt_block                     shift and go to state 53

state 45

    (10) func_declaration -> type MAIN LPAREN RPAREN stmt_block .

    INT             reduce using rule 10 (func_declaration -> type MAIN LPAREN RPAREN stmt_block .)
    FLOAT           reduce using rule 10 (func_declaration -> type MAIN LPAREN RPAREN stmt_block .)
    VOID            reduce using rule 10 (func_declaration -> type MAIN LPAREN RPAREN stmt_block .)
    $end            reduce using rule 10 (func_declaration -> type MAIN LPAREN RPAREN stmt_block .)


state 46

    (16) param -> type TIMES ID .

    COMMA           reduce using rule 16 (param -> type TIMES ID .)
    RPAREN          reduce using rule 16 (param -> type TIMES ID .)


state 47

    (5) func_declaration -> type ID LPAREN params RPAREN stmt_block .

    INT             reduce using rule 5 (func_declaration -> type ID LPAREN params RPAREN stmt_block .)
    FLOAT           reduce using rule 5 (func_declaration -> type ID LPAREN params RPAREN stmt_block .)
    VOID            reduce using rule 5 (func_declaration -> type ID LPAREN params RPAREN stmt_block .)
    $end            reduce using rule 5 (func_declaration -> type ID LPAREN params RPAREN stmt_block .)


state 48

    (40) stmt_block -> LBRACE stmt_list . RBRACE
    (41) stmt_list -> stmt_list . genstmt
    (17) genstmt -> . mstmt
    (18) genstmt -> . umstmt
    (19) mstmt -> . IF LPAREN expr RPAREN mstmt ELSE mstmt
    (20) mstmt -> . stmt
    (21) umstmt -> . IF LPAREN expr RPAREN genstmt
    (22) umstmt -> . IF LPAREN expr RPAREN mstmt ELSE umstmt
    (23) stmt -> . expr SEMICOLON
    (24) stmt -> . declaration SEMICOLON
    (25) stmt -> . stmt_block
    (26) stmt -> . stmt_forloop
    (27) stmt -> . stmt_return
    (28) stmt -> . SEMICOLON
    (29) stmt -> . expr error
    (30) stmt -> . PRINT LPAREN argument_list RPAREN SEMICOLON
    (46) expr -> . ID EQUAL expr
    (47) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (48) expr -> . TIMES ID EQUAL expr
    (49) expr -> . incr_expr
    (50) expr -> . basic_expr
    (31) declaration -> . declaration COMMA idbracket
    (32) declaration -> . declaration COMMA TIMES idbracket
    (33) declaration -> . type idbracket
    (34) declaration -> . type TIMES idbracket
    (40) stmt_block -> . LBRACE stmt_list RBRACE
    (43) stmt_forloop -> . FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (44) stmt_return -> . RETURN expr SEMICOLON
    (45) stmt_return -> . RETURN SEMICOLON
    (57) incr_expr -> . ID INCREMENT
    (58) incr_expr -> . INCREMENT ID
    (51) basic_expr -> . basic_expr compare arith_expr
    (52) basic_expr -> . arith_expr
    (37) type -> . INT
    (38) type -> . FLOAT
    (39) type -> . VOID
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    RBRACE          shift and go to state 54
    IF              shift and go to state 58
    SEMICOLON       shift and go to state 62
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    TIMES           shift and go to state 70
    LBRACE          shift and go to state 39
    FOR             shift and go to state 74
    RETURN          shift and go to state 75
    INCREMENT       shift and go to state 76
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    ADDRESS         shift and go to state 80

    genstmt                        shift and go to state 55
    mstmt                          shift and go to state 56
    umstmt                         shift and go to state 57
    expr                           shift and go to state 60
    stmt                           shift and go to state 61
    declaration                    shift and go to state 63
    stmt_block                     shift and go to state 64
    stmt_forloop                   shift and go to state 65
    stmt_return                    shift and go to state 66
    arith_expr                     shift and go to state 69
    incr_expr                      shift and go to state 71
    basic_expr                     shift and go to state 72
    type                           shift and go to state 73

state 49

    (42) stmt_list -> empty .

    RBRACE          reduce using rule 42 (stmt_list -> empty .)
    IF              reduce using rule 42 (stmt_list -> empty .)
    SEMICOLON       reduce using rule 42 (stmt_list -> empty .)
    PRINT           reduce using rule 42 (stmt_list -> empty .)
    ID              reduce using rule 42 (stmt_list -> empty .)
    TIMES           reduce using rule 42 (stmt_list -> empty .)
    LBRACE          reduce using rule 42 (stmt_list -> empty .)
    FOR             reduce using rule 42 (stmt_list -> empty .)
    RETURN          reduce using rule 42 (stmt_list -> empty .)
    INCREMENT       reduce using rule 42 (stmt_list -> empty .)
    INT             reduce using rule 42 (stmt_list -> empty .)
    FLOAT           reduce using rule 42 (stmt_list -> empty .)
    VOID            reduce using rule 42 (stmt_list -> empty .)
    MINUS           reduce using rule 42 (stmt_list -> empty .)
    LPAREN          reduce using rule 42 (stmt_list -> empty .)
    FNUM            reduce using rule 42 (stmt_list -> empty .)
    INUM            reduce using rule 42 (stmt_list -> empty .)
    ADDRESS         reduce using rule 42 (stmt_list -> empty .)


state 50

    (14) param_list -> param_list COMMA param .

    COMMA           reduce using rule 14 (param_list -> param_list COMMA param .)
    RPAREN          reduce using rule 14 (param_list -> param_list COMMA param .)


state 51

    (7) func_declaration -> type TIMES ID LPAREN params RPAREN . stmt_block
    (40) stmt_block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 39

    stmt_block                     shift and go to state 81

state 52

    (8) func_declaration -> type TIMES ID LPAREN RPAREN stmt_block .

    INT             reduce using rule 8 (func_declaration -> type TIMES ID LPAREN RPAREN stmt_block .)
    FLOAT           reduce using rule 8 (func_declaration -> type TIMES ID LPAREN RPAREN stmt_block .)
    VOID            reduce using rule 8 (func_declaration -> type TIMES ID LPAREN RPAREN stmt_block .)
    $end            reduce using rule 8 (func_declaration -> type TIMES ID LPAREN RPAREN stmt_block .)


state 53

    (9) func_declaration -> type MAIN LPAREN params RPAREN stmt_block .

    INT             reduce using rule 9 (func_declaration -> type MAIN LPAREN params RPAREN stmt_block .)
    FLOAT           reduce using rule 9 (func_declaration -> type MAIN LPAREN params RPAREN stmt_block .)
    VOID            reduce using rule 9 (func_declaration -> type MAIN LPAREN params RPAREN stmt_block .)
    $end            reduce using rule 9 (func_declaration -> type MAIN LPAREN params RPAREN stmt_block .)


state 54

    (40) stmt_block -> LBRACE stmt_list RBRACE .

    INT             reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    $end            reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    IF              reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    SEMICOLON       reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    PRINT           reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    ID              reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    TIMES           reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    LBRACE          reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    INCREMENT       reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    MINUS           reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    LPAREN          reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    FNUM            reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    INUM            reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    ADDRESS         reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)
    ELSE            reduce using rule 40 (stmt_block -> LBRACE stmt_list RBRACE .)


state 55

    (41) stmt_list -> stmt_list genstmt .

    RBRACE          reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    IF              reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    SEMICOLON       reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    PRINT           reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    ID              reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    TIMES           reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    LBRACE          reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    FOR             reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    RETURN          reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    INCREMENT       reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    INT             reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    FLOAT           reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    VOID            reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    MINUS           reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    LPAREN          reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    FNUM            reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    INUM            reduce using rule 41 (stmt_list -> stmt_list genstmt .)
    ADDRESS         reduce using rule 41 (stmt_list -> stmt_list genstmt .)


state 56

    (17) genstmt -> mstmt .

    RBRACE          reduce using rule 17 (genstmt -> mstmt .)
    IF              reduce using rule 17 (genstmt -> mstmt .)
    SEMICOLON       reduce using rule 17 (genstmt -> mstmt .)
    PRINT           reduce using rule 17 (genstmt -> mstmt .)
    ID              reduce using rule 17 (genstmt -> mstmt .)
    TIMES           reduce using rule 17 (genstmt -> mstmt .)
    LBRACE          reduce using rule 17 (genstmt -> mstmt .)
    FOR             reduce using rule 17 (genstmt -> mstmt .)
    RETURN          reduce using rule 17 (genstmt -> mstmt .)
    INCREMENT       reduce using rule 17 (genstmt -> mstmt .)
    INT             reduce using rule 17 (genstmt -> mstmt .)
    FLOAT           reduce using rule 17 (genstmt -> mstmt .)
    VOID            reduce using rule 17 (genstmt -> mstmt .)
    MINUS           reduce using rule 17 (genstmt -> mstmt .)
    LPAREN          reduce using rule 17 (genstmt -> mstmt .)
    FNUM            reduce using rule 17 (genstmt -> mstmt .)
    INUM            reduce using rule 17 (genstmt -> mstmt .)
    ADDRESS         reduce using rule 17 (genstmt -> mstmt .)


state 57

    (18) genstmt -> umstmt .

    RBRACE          reduce using rule 18 (genstmt -> umstmt .)
    IF              reduce using rule 18 (genstmt -> umstmt .)
    SEMICOLON       reduce using rule 18 (genstmt -> umstmt .)
    PRINT           reduce using rule 18 (genstmt -> umstmt .)
    ID              reduce using rule 18 (genstmt -> umstmt .)
    TIMES           reduce using rule 18 (genstmt -> umstmt .)
    LBRACE          reduce using rule 18 (genstmt -> umstmt .)
    FOR             reduce using rule 18 (genstmt -> umstmt .)
    RETURN          reduce using rule 18 (genstmt -> umstmt .)
    INCREMENT       reduce using rule 18 (genstmt -> umstmt .)
    INT             reduce using rule 18 (genstmt -> umstmt .)
    FLOAT           reduce using rule 18 (genstmt -> umstmt .)
    VOID            reduce using rule 18 (genstmt -> umstmt .)
    MINUS           reduce using rule 18 (genstmt -> umstmt .)
    LPAREN          reduce using rule 18 (genstmt -> umstmt .)
    FNUM            reduce using rule 18 (genstmt -> umstmt .)
    INUM            reduce using rule 18 (genstmt -> umstmt .)
    ADDRESS         reduce using rule 18 (genstmt -> umstmt .)


state 58

    (19) mstmt -> IF . LPAREN expr RPAREN mstmt ELSE mstmt
    (21) umstmt -> IF . LPAREN expr RPAREN genstmt
    (22) umstmt -> IF . LPAREN expr RPAREN mstmt ELSE umstmt

    LPAREN          shift and go to state 82


state 59

    (60) arith_expr -> LPAREN . arith_expr RPAREN
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    arith_expr                     shift and go to state 83

state 60

    (23) stmt -> expr . SEMICOLON
    (29) stmt -> expr . error

    SEMICOLON       shift and go to state 86
    error           shift and go to state 87


state 61

    (20) mstmt -> stmt .

    RBRACE          reduce using rule 20 (mstmt -> stmt .)
    IF              reduce using rule 20 (mstmt -> stmt .)
    SEMICOLON       reduce using rule 20 (mstmt -> stmt .)
    PRINT           reduce using rule 20 (mstmt -> stmt .)
    ID              reduce using rule 20 (mstmt -> stmt .)
    TIMES           reduce using rule 20 (mstmt -> stmt .)
    LBRACE          reduce using rule 20 (mstmt -> stmt .)
    FOR             reduce using rule 20 (mstmt -> stmt .)
    RETURN          reduce using rule 20 (mstmt -> stmt .)
    INCREMENT       reduce using rule 20 (mstmt -> stmt .)
    INT             reduce using rule 20 (mstmt -> stmt .)
    FLOAT           reduce using rule 20 (mstmt -> stmt .)
    VOID            reduce using rule 20 (mstmt -> stmt .)
    MINUS           reduce using rule 20 (mstmt -> stmt .)
    LPAREN          reduce using rule 20 (mstmt -> stmt .)
    FNUM            reduce using rule 20 (mstmt -> stmt .)
    INUM            reduce using rule 20 (mstmt -> stmt .)
    ADDRESS         reduce using rule 20 (mstmt -> stmt .)
    ELSE            reduce using rule 20 (mstmt -> stmt .)


state 62

    (28) stmt -> SEMICOLON .

    RBRACE          reduce using rule 28 (stmt -> SEMICOLON .)
    IF              reduce using rule 28 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 28 (stmt -> SEMICOLON .)
    PRINT           reduce using rule 28 (stmt -> SEMICOLON .)
    ID              reduce using rule 28 (stmt -> SEMICOLON .)
    TIMES           reduce using rule 28 (stmt -> SEMICOLON .)
    LBRACE          reduce using rule 28 (stmt -> SEMICOLON .)
    FOR             reduce using rule 28 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 28 (stmt -> SEMICOLON .)
    INCREMENT       reduce using rule 28 (stmt -> SEMICOLON .)
    INT             reduce using rule 28 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 28 (stmt -> SEMICOLON .)
    VOID            reduce using rule 28 (stmt -> SEMICOLON .)
    MINUS           reduce using rule 28 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 28 (stmt -> SEMICOLON .)
    FNUM            reduce using rule 28 (stmt -> SEMICOLON .)
    INUM            reduce using rule 28 (stmt -> SEMICOLON .)
    ADDRESS         reduce using rule 28 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 28 (stmt -> SEMICOLON .)


state 63

    (24) stmt -> declaration . SEMICOLON
    (31) declaration -> declaration . COMMA idbracket
    (32) declaration -> declaration . COMMA TIMES idbracket

    SEMICOLON       shift and go to state 88
    COMMA           shift and go to state 11


state 64

    (25) stmt -> stmt_block .

    RBRACE          reduce using rule 25 (stmt -> stmt_block .)
    IF              reduce using rule 25 (stmt -> stmt_block .)
    SEMICOLON       reduce using rule 25 (stmt -> stmt_block .)
    PRINT           reduce using rule 25 (stmt -> stmt_block .)
    ID              reduce using rule 25 (stmt -> stmt_block .)
    TIMES           reduce using rule 25 (stmt -> stmt_block .)
    LBRACE          reduce using rule 25 (stmt -> stmt_block .)
    FOR             reduce using rule 25 (stmt -> stmt_block .)
    RETURN          reduce using rule 25 (stmt -> stmt_block .)
    INCREMENT       reduce using rule 25 (stmt -> stmt_block .)
    INT             reduce using rule 25 (stmt -> stmt_block .)
    FLOAT           reduce using rule 25 (stmt -> stmt_block .)
    VOID            reduce using rule 25 (stmt -> stmt_block .)
    MINUS           reduce using rule 25 (stmt -> stmt_block .)
    LPAREN          reduce using rule 25 (stmt -> stmt_block .)
    FNUM            reduce using rule 25 (stmt -> stmt_block .)
    INUM            reduce using rule 25 (stmt -> stmt_block .)
    ADDRESS         reduce using rule 25 (stmt -> stmt_block .)
    ELSE            reduce using rule 25 (stmt -> stmt_block .)


state 65

    (26) stmt -> stmt_forloop .

    RBRACE          reduce using rule 26 (stmt -> stmt_forloop .)
    IF              reduce using rule 26 (stmt -> stmt_forloop .)
    SEMICOLON       reduce using rule 26 (stmt -> stmt_forloop .)
    PRINT           reduce using rule 26 (stmt -> stmt_forloop .)
    ID              reduce using rule 26 (stmt -> stmt_forloop .)
    TIMES           reduce using rule 26 (stmt -> stmt_forloop .)
    LBRACE          reduce using rule 26 (stmt -> stmt_forloop .)
    FOR             reduce using rule 26 (stmt -> stmt_forloop .)
    RETURN          reduce using rule 26 (stmt -> stmt_forloop .)
    INCREMENT       reduce using rule 26 (stmt -> stmt_forloop .)
    INT             reduce using rule 26 (stmt -> stmt_forloop .)
    FLOAT           reduce using rule 26 (stmt -> stmt_forloop .)
    VOID            reduce using rule 26 (stmt -> stmt_forloop .)
    MINUS           reduce using rule 26 (stmt -> stmt_forloop .)
    LPAREN          reduce using rule 26 (stmt -> stmt_forloop .)
    FNUM            reduce using rule 26 (stmt -> stmt_forloop .)
    INUM            reduce using rule 26 (stmt -> stmt_forloop .)
    ADDRESS         reduce using rule 26 (stmt -> stmt_forloop .)
    ELSE            reduce using rule 26 (stmt -> stmt_forloop .)


state 66

    (27) stmt -> stmt_return .

    RBRACE          reduce using rule 27 (stmt -> stmt_return .)
    IF              reduce using rule 27 (stmt -> stmt_return .)
    SEMICOLON       reduce using rule 27 (stmt -> stmt_return .)
    PRINT           reduce using rule 27 (stmt -> stmt_return .)
    ID              reduce using rule 27 (stmt -> stmt_return .)
    TIMES           reduce using rule 27 (stmt -> stmt_return .)
    LBRACE          reduce using rule 27 (stmt -> stmt_return .)
    FOR             reduce using rule 27 (stmt -> stmt_return .)
    RETURN          reduce using rule 27 (stmt -> stmt_return .)
    INCREMENT       reduce using rule 27 (stmt -> stmt_return .)
    INT             reduce using rule 27 (stmt -> stmt_return .)
    FLOAT           reduce using rule 27 (stmt -> stmt_return .)
    VOID            reduce using rule 27 (stmt -> stmt_return .)
    MINUS           reduce using rule 27 (stmt -> stmt_return .)
    LPAREN          reduce using rule 27 (stmt -> stmt_return .)
    FNUM            reduce using rule 27 (stmt -> stmt_return .)
    INUM            reduce using rule 27 (stmt -> stmt_return .)
    ADDRESS         reduce using rule 27 (stmt -> stmt_return .)
    ELSE            reduce using rule 27 (stmt -> stmt_return .)


state 67

    (30) stmt -> PRINT . LPAREN argument_list RPAREN SEMICOLON

    LPAREN          shift and go to state 89


state 68

    (46) expr -> ID . EQUAL expr
    (47) expr -> ID . LBRACKET arith_expr RBRACKET EQUAL expr
    (57) incr_expr -> ID . INCREMENT
    (65) arith_expr -> ID .
    (72) arith_expr -> ID . LBRACKET arith_expr RBRACKET
    (74) arith_expr -> ID . LPAREN argument_list RPAREN

    EQUAL           shift and go to state 90
    LBRACKET        shift and go to state 91
    INCREMENT       shift and go to state 92
    PLUS            reduce using rule 65 (arith_expr -> ID .)
    MINUS           reduce using rule 65 (arith_expr -> ID .)
    TIMES           reduce using rule 65 (arith_expr -> ID .)
    DIV             reduce using rule 65 (arith_expr -> ID .)
    EQ              reduce using rule 65 (arith_expr -> ID .)
    NEQ             reduce using rule 65 (arith_expr -> ID .)
    GT              reduce using rule 65 (arith_expr -> ID .)
    LT              reduce using rule 65 (arith_expr -> ID .)
    SEMICOLON       reduce using rule 65 (arith_expr -> ID .)
    error           reduce using rule 65 (arith_expr -> ID .)
    RPAREN          reduce using rule 65 (arith_expr -> ID .)
    LPAREN          shift and go to state 93


state 69

    (52) basic_expr -> arith_expr .
    (61) arith_expr -> arith_expr . PLUS arith_expr
    (62) arith_expr -> arith_expr . MINUS arith_expr
    (63) arith_expr -> arith_expr . TIMES arith_expr
    (64) arith_expr -> arith_expr . DIV arith_expr

    EQ              reduce using rule 52 (basic_expr -> arith_expr .)
    NEQ             reduce using rule 52 (basic_expr -> arith_expr .)
    GT              reduce using rule 52 (basic_expr -> arith_expr .)
    LT              reduce using rule 52 (basic_expr -> arith_expr .)
    SEMICOLON       reduce using rule 52 (basic_expr -> arith_expr .)
    error           reduce using rule 52 (basic_expr -> arith_expr .)
    RPAREN          reduce using rule 52 (basic_expr -> arith_expr .)
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    TIMES           shift and go to state 96
    DIV             shift and go to state 97


state 70

    (48) expr -> TIMES . ID EQUAL expr
    (68) arith_expr -> TIMES . ID
    (69) arith_expr -> TIMES . LPAREN arith_expr RPAREN
    (70) arith_expr -> TIMES . ID LPAREN argument_list RPAREN
    (73) arith_expr -> TIMES . ID LBRACKET arith_expr RBRACKET

    ID              shift and go to state 98
    LPAREN          shift and go to state 99


state 71

    (49) expr -> incr_expr .

    SEMICOLON       reduce using rule 49 (expr -> incr_expr .)
    error           reduce using rule 49 (expr -> incr_expr .)
    RPAREN          reduce using rule 49 (expr -> incr_expr .)


state 72

    (50) expr -> basic_expr .
    (51) basic_expr -> basic_expr . compare arith_expr
    (53) compare -> . EQ
    (54) compare -> . NEQ
    (55) compare -> . GT
    (56) compare -> . LT

    SEMICOLON       reduce using rule 50 (expr -> basic_expr .)
    error           reduce using rule 50 (expr -> basic_expr .)
    RPAREN          reduce using rule 50 (expr -> basic_expr .)
    EQ              shift and go to state 101
    NEQ             shift and go to state 102
    GT              shift and go to state 103
    LT              shift and go to state 104

    compare                        shift and go to state 100

state 73

    (33) declaration -> type . idbracket
    (34) declaration -> type . TIMES idbracket
    (35) idbracket -> . ID
    (36) idbracket -> . ID LBRACKET INUM RBRACKET

    TIMES           shift and go to state 105
    ID              shift and go to state 18

    idbracket                      shift and go to state 15

state 74

    (43) stmt_forloop -> FOR . LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt

    LPAREN          shift and go to state 106


state 75

    (44) stmt_return -> RETURN . expr SEMICOLON
    (45) stmt_return -> RETURN . SEMICOLON
    (46) expr -> . ID EQUAL expr
    (47) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (48) expr -> . TIMES ID EQUAL expr
    (49) expr -> . incr_expr
    (50) expr -> . basic_expr
    (57) incr_expr -> . ID INCREMENT
    (58) incr_expr -> . INCREMENT ID
    (51) basic_expr -> . basic_expr compare arith_expr
    (52) basic_expr -> . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    SEMICOLON       shift and go to state 108
    ID              shift and go to state 68
    TIMES           shift and go to state 70
    INCREMENT       shift and go to state 76
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    ADDRESS         shift and go to state 80

    expr                           shift and go to state 107
    arith_expr                     shift and go to state 69
    incr_expr                      shift and go to state 71
    basic_expr                     shift and go to state 72

state 76

    (58) incr_expr -> INCREMENT . ID

    ID              shift and go to state 109


state 77

    (59) arith_expr -> MINUS . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    arith_expr                     shift and go to state 110

state 78

    (66) arith_expr -> FNUM .

    PLUS            reduce using rule 66 (arith_expr -> FNUM .)
    MINUS           reduce using rule 66 (arith_expr -> FNUM .)
    TIMES           reduce using rule 66 (arith_expr -> FNUM .)
    DIV             reduce using rule 66 (arith_expr -> FNUM .)
    EQ              reduce using rule 66 (arith_expr -> FNUM .)
    NEQ             reduce using rule 66 (arith_expr -> FNUM .)
    GT              reduce using rule 66 (arith_expr -> FNUM .)
    LT              reduce using rule 66 (arith_expr -> FNUM .)
    SEMICOLON       reduce using rule 66 (arith_expr -> FNUM .)
    error           reduce using rule 66 (arith_expr -> FNUM .)
    RPAREN          reduce using rule 66 (arith_expr -> FNUM .)
    COMMA           reduce using rule 66 (arith_expr -> FNUM .)
    RBRACKET        reduce using rule 66 (arith_expr -> FNUM .)


state 79

    (67) arith_expr -> INUM .

    PLUS            reduce using rule 67 (arith_expr -> INUM .)
    MINUS           reduce using rule 67 (arith_expr -> INUM .)
    TIMES           reduce using rule 67 (arith_expr -> INUM .)
    DIV             reduce using rule 67 (arith_expr -> INUM .)
    EQ              reduce using rule 67 (arith_expr -> INUM .)
    NEQ             reduce using rule 67 (arith_expr -> INUM .)
    GT              reduce using rule 67 (arith_expr -> INUM .)
    LT              reduce using rule 67 (arith_expr -> INUM .)
    SEMICOLON       reduce using rule 67 (arith_expr -> INUM .)
    error           reduce using rule 67 (arith_expr -> INUM .)
    RPAREN          reduce using rule 67 (arith_expr -> INUM .)
    COMMA           reduce using rule 67 (arith_expr -> INUM .)
    RBRACKET        reduce using rule 67 (arith_expr -> INUM .)


state 80

    (71) arith_expr -> ADDRESS . ID

    ID              shift and go to state 111


state 81

    (7) func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .

    INT             reduce using rule 7 (func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .)
    FLOAT           reduce using rule 7 (func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .)
    VOID            reduce using rule 7 (func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .)
    $end            reduce using rule 7 (func_declaration -> type TIMES ID LPAREN params RPAREN stmt_block .)


state 82

    (19) mstmt -> IF LPAREN . expr RPAREN mstmt ELSE mstmt
    (21) umstmt -> IF LPAREN . expr RPAREN genstmt
    (22) umstmt -> IF LPAREN . expr RPAREN mstmt ELSE umstmt
    (46) expr -> . ID EQUAL expr
    (47) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (48) expr -> . TIMES ID EQUAL expr
    (49) expr -> . incr_expr
    (50) expr -> . basic_expr
    (57) incr_expr -> . ID INCREMENT
    (58) incr_expr -> . INCREMENT ID
    (51) basic_expr -> . basic_expr compare arith_expr
    (52) basic_expr -> . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 68
    TIMES           shift and go to state 70
    INCREMENT       shift and go to state 76
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    ADDRESS         shift and go to state 80

    expr                           shift and go to state 112
    arith_expr                     shift and go to state 69
    incr_expr                      shift and go to state 71
    basic_expr                     shift and go to state 72

state 83

    (60) arith_expr -> LPAREN arith_expr . RPAREN
    (61) arith_expr -> arith_expr . PLUS arith_expr
    (62) arith_expr -> arith_expr . MINUS arith_expr
    (63) arith_expr -> arith_expr . TIMES arith_expr
    (64) arith_expr -> arith_expr . DIV arith_expr

    RPAREN          shift and go to state 113
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    TIMES           shift and go to state 96
    DIV             shift and go to state 97


state 84

    (68) arith_expr -> TIMES . ID
    (69) arith_expr -> TIMES . LPAREN arith_expr RPAREN
    (70) arith_expr -> TIMES . ID LPAREN argument_list RPAREN
    (73) arith_expr -> TIMES . ID LBRACKET arith_expr RBRACKET

    ID              shift and go to state 114
    LPAREN          shift and go to state 99


state 85

    (65) arith_expr -> ID .
    (72) arith_expr -> ID . LBRACKET arith_expr RBRACKET
    (74) arith_expr -> ID . LPAREN argument_list RPAREN

    RPAREN          reduce using rule 65 (arith_expr -> ID .)
    PLUS            reduce using rule 65 (arith_expr -> ID .)
    MINUS           reduce using rule 65 (arith_expr -> ID .)
    TIMES           reduce using rule 65 (arith_expr -> ID .)
    DIV             reduce using rule 65 (arith_expr -> ID .)
    EQ              reduce using rule 65 (arith_expr -> ID .)
    NEQ             reduce using rule 65 (arith_expr -> ID .)
    GT              reduce using rule 65 (arith_expr -> ID .)
    LT              reduce using rule 65 (arith_expr -> ID .)
    SEMICOLON       reduce using rule 65 (arith_expr -> ID .)
    error           reduce using rule 65 (arith_expr -> ID .)
    COMMA           reduce using rule 65 (arith_expr -> ID .)
    RBRACKET        reduce using rule 65 (arith_expr -> ID .)
    LBRACKET        shift and go to state 115
    LPAREN          shift and go to state 93


state 86

    (23) stmt -> expr SEMICOLON .

    RBRACE          reduce using rule 23 (stmt -> expr SEMICOLON .)
    IF              reduce using rule 23 (stmt -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 23 (stmt -> expr SEMICOLON .)
    PRINT           reduce using rule 23 (stmt -> expr SEMICOLON .)
    ID              reduce using rule 23 (stmt -> expr SEMICOLON .)
    TIMES           reduce using rule 23 (stmt -> expr SEMICOLON .)
    LBRACE          reduce using rule 23 (stmt -> expr SEMICOLON .)
    FOR             reduce using rule 23 (stmt -> expr SEMICOLON .)
    RETURN          reduce using rule 23 (stmt -> expr SEMICOLON .)
    INCREMENT       reduce using rule 23 (stmt -> expr SEMICOLON .)
    INT             reduce using rule 23 (stmt -> expr SEMICOLON .)
    FLOAT           reduce using rule 23 (stmt -> expr SEMICOLON .)
    VOID            reduce using rule 23 (stmt -> expr SEMICOLON .)
    MINUS           reduce using rule 23 (stmt -> expr SEMICOLON .)
    LPAREN          reduce using rule 23 (stmt -> expr SEMICOLON .)
    FNUM            reduce using rule 23 (stmt -> expr SEMICOLON .)
    INUM            reduce using rule 23 (stmt -> expr SEMICOLON .)
    ADDRESS         reduce using rule 23 (stmt -> expr SEMICOLON .)
    ELSE            reduce using rule 23 (stmt -> expr SEMICOLON .)


state 87

    (29) stmt -> expr error .

    RBRACE          reduce using rule 29 (stmt -> expr error .)
    IF              reduce using rule 29 (stmt -> expr error .)
    SEMICOLON       reduce using rule 29 (stmt -> expr error .)
    PRINT           reduce using rule 29 (stmt -> expr error .)
    ID              reduce using rule 29 (stmt -> expr error .)
    TIMES           reduce using rule 29 (stmt -> expr error .)
    LBRACE          reduce using rule 29 (stmt -> expr error .)
    FOR             reduce using rule 29 (stmt -> expr error .)
    RETURN          reduce using rule 29 (stmt -> expr error .)
    INCREMENT       reduce using rule 29 (stmt -> expr error .)
    INT             reduce using rule 29 (stmt -> expr error .)
    FLOAT           reduce using rule 29 (stmt -> expr error .)
    VOID            reduce using rule 29 (stmt -> expr error .)
    MINUS           reduce using rule 29 (stmt -> expr error .)
    LPAREN          reduce using rule 29 (stmt -> expr error .)
    FNUM            reduce using rule 29 (stmt -> expr error .)
    INUM            reduce using rule 29 (stmt -> expr error .)
    ADDRESS         reduce using rule 29 (stmt -> expr error .)
    ELSE            reduce using rule 29 (stmt -> expr error .)


state 88

    (24) stmt -> declaration SEMICOLON .

    RBRACE          reduce using rule 24 (stmt -> declaration SEMICOLON .)
    IF              reduce using rule 24 (stmt -> declaration SEMICOLON .)
    SEMICOLON       reduce using rule 24 (stmt -> declaration SEMICOLON .)
    PRINT           reduce using rule 24 (stmt -> declaration SEMICOLON .)
    ID              reduce using rule 24 (stmt -> declaration SEMICOLON .)
    TIMES           reduce using rule 24 (stmt -> declaration SEMICOLON .)
    LBRACE          reduce using rule 24 (stmt -> declaration SEMICOLON .)
    FOR             reduce using rule 24 (stmt -> declaration SEMICOLON .)
    RETURN          reduce using rule 24 (stmt -> declaration SEMICOLON .)
    INCREMENT       reduce using rule 24 (stmt -> declaration SEMICOLON .)
    INT             reduce using rule 24 (stmt -> declaration SEMICOLON .)
    FLOAT           reduce using rule 24 (stmt -> declaration SEMICOLON .)
    VOID            reduce using rule 24 (stmt -> declaration SEMICOLON .)
    MINUS           reduce using rule 24 (stmt -> declaration SEMICOLON .)
    LPAREN          reduce using rule 24 (stmt -> declaration SEMICOLON .)
    FNUM            reduce using rule 24 (stmt -> declaration SEMICOLON .)
    INUM            reduce using rule 24 (stmt -> declaration SEMICOLON .)
    ADDRESS         reduce using rule 24 (stmt -> declaration SEMICOLON .)
    ELSE            reduce using rule 24 (stmt -> declaration SEMICOLON .)


state 89

    (30) stmt -> PRINT LPAREN . argument_list RPAREN SEMICOLON
    (75) argument_list -> . argument
    (76) argument_list -> . argument_list COMMA argument
    (77) argument -> . empty
    (78) argument -> . arith_expr
    (79) argument -> . LITERAL
    (80) argument -> . error
    (81) empty -> .
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    LITERAL         shift and go to state 120
    error           shift and go to state 121
    RPAREN          reduce using rule 81 (empty -> .)
    COMMA           reduce using rule 81 (empty -> .)
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    argument_list                  shift and go to state 116
    argument                       shift and go to state 117
    empty                          shift and go to state 118
    arith_expr                     shift and go to state 119

state 90

    (46) expr -> ID EQUAL . expr
    (46) expr -> . ID EQUAL expr
    (47) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (48) expr -> . TIMES ID EQUAL expr
    (49) expr -> . incr_expr
    (50) expr -> . basic_expr
    (57) incr_expr -> . ID INCREMENT
    (58) incr_expr -> . INCREMENT ID
    (51) basic_expr -> . basic_expr compare arith_expr
    (52) basic_expr -> . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 68
    TIMES           shift and go to state 70
    INCREMENT       shift and go to state 76
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    ADDRESS         shift and go to state 80

    expr                           shift and go to state 122
    arith_expr                     shift and go to state 69
    incr_expr                      shift and go to state 71
    basic_expr                     shift and go to state 72

state 91

    (47) expr -> ID LBRACKET . arith_expr RBRACKET EQUAL expr
    (72) arith_expr -> ID LBRACKET . arith_expr RBRACKET
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    arith_expr                     shift and go to state 123

state 92

    (57) incr_expr -> ID INCREMENT .

    SEMICOLON       reduce using rule 57 (incr_expr -> ID INCREMENT .)
    error           reduce using rule 57 (incr_expr -> ID INCREMENT .)
    RPAREN          reduce using rule 57 (incr_expr -> ID INCREMENT .)


state 93

    (74) arith_expr -> ID LPAREN . argument_list RPAREN
    (75) argument_list -> . argument
    (76) argument_list -> . argument_list COMMA argument
    (77) argument -> . empty
    (78) argument -> . arith_expr
    (79) argument -> . LITERAL
    (80) argument -> . error
    (81) empty -> .
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    LITERAL         shift and go to state 120
    error           shift and go to state 121
    RPAREN          reduce using rule 81 (empty -> .)
    COMMA           reduce using rule 81 (empty -> .)
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    argument_list                  shift and go to state 124
    argument                       shift and go to state 117
    empty                          shift and go to state 118
    arith_expr                     shift and go to state 119

state 94

    (61) arith_expr -> arith_expr PLUS . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    arith_expr                     shift and go to state 125

state 95

    (62) arith_expr -> arith_expr MINUS . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    arith_expr                     shift and go to state 126

state 96

    (63) arith_expr -> arith_expr TIMES . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    arith_expr                     shift and go to state 127

state 97

    (64) arith_expr -> arith_expr DIV . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    arith_expr                     shift and go to state 128

state 98

    (48) expr -> TIMES ID . EQUAL expr
    (68) arith_expr -> TIMES ID .
    (70) arith_expr -> TIMES ID . LPAREN argument_list RPAREN
    (73) arith_expr -> TIMES ID . LBRACKET arith_expr RBRACKET

    EQUAL           shift and go to state 129
    PLUS            reduce using rule 68 (arith_expr -> TIMES ID .)
    MINUS           reduce using rule 68 (arith_expr -> TIMES ID .)
    TIMES           reduce using rule 68 (arith_expr -> TIMES ID .)
    DIV             reduce using rule 68 (arith_expr -> TIMES ID .)
    EQ              reduce using rule 68 (arith_expr -> TIMES ID .)
    NEQ             reduce using rule 68 (arith_expr -> TIMES ID .)
    GT              reduce using rule 68 (arith_expr -> TIMES ID .)
    LT              reduce using rule 68 (arith_expr -> TIMES ID .)
    SEMICOLON       reduce using rule 68 (arith_expr -> TIMES ID .)
    error           reduce using rule 68 (arith_expr -> TIMES ID .)
    RPAREN          reduce using rule 68 (arith_expr -> TIMES ID .)
    LPAREN          shift and go to state 130
    LBRACKET        shift and go to state 131


state 99

    (69) arith_expr -> TIMES LPAREN . arith_expr RPAREN
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    arith_expr                     shift and go to state 132

state 100

    (51) basic_expr -> basic_expr compare . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    arith_expr                     shift and go to state 133

state 101

    (53) compare -> EQ .

    MINUS           reduce using rule 53 (compare -> EQ .)
    LPAREN          reduce using rule 53 (compare -> EQ .)
    ID              reduce using rule 53 (compare -> EQ .)
    FNUM            reduce using rule 53 (compare -> EQ .)
    INUM            reduce using rule 53 (compare -> EQ .)
    TIMES           reduce using rule 53 (compare -> EQ .)
    ADDRESS         reduce using rule 53 (compare -> EQ .)


state 102

    (54) compare -> NEQ .

    MINUS           reduce using rule 54 (compare -> NEQ .)
    LPAREN          reduce using rule 54 (compare -> NEQ .)
    ID              reduce using rule 54 (compare -> NEQ .)
    FNUM            reduce using rule 54 (compare -> NEQ .)
    INUM            reduce using rule 54 (compare -> NEQ .)
    TIMES           reduce using rule 54 (compare -> NEQ .)
    ADDRESS         reduce using rule 54 (compare -> NEQ .)


state 103

    (55) compare -> GT .

    MINUS           reduce using rule 55 (compare -> GT .)
    LPAREN          reduce using rule 55 (compare -> GT .)
    ID              reduce using rule 55 (compare -> GT .)
    FNUM            reduce using rule 55 (compare -> GT .)
    INUM            reduce using rule 55 (compare -> GT .)
    TIMES           reduce using rule 55 (compare -> GT .)
    ADDRESS         reduce using rule 55 (compare -> GT .)


state 104

    (56) compare -> LT .

    MINUS           reduce using rule 56 (compare -> LT .)
    LPAREN          reduce using rule 56 (compare -> LT .)
    ID              reduce using rule 56 (compare -> LT .)
    FNUM            reduce using rule 56 (compare -> LT .)
    INUM            reduce using rule 56 (compare -> LT .)
    TIMES           reduce using rule 56 (compare -> LT .)
    ADDRESS         reduce using rule 56 (compare -> LT .)


state 105

    (34) declaration -> type TIMES . idbracket
    (35) idbracket -> . ID
    (36) idbracket -> . ID LBRACKET INUM RBRACKET

    ID              shift and go to state 18

    idbracket                      shift and go to state 22

state 106

    (43) stmt_forloop -> FOR LPAREN . expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (46) expr -> . ID EQUAL expr
    (47) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (48) expr -> . TIMES ID EQUAL expr
    (49) expr -> . incr_expr
    (50) expr -> . basic_expr
    (57) incr_expr -> . ID INCREMENT
    (58) incr_expr -> . INCREMENT ID
    (51) basic_expr -> . basic_expr compare arith_expr
    (52) basic_expr -> . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 68
    TIMES           shift and go to state 70
    INCREMENT       shift and go to state 76
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    ADDRESS         shift and go to state 80

    expr                           shift and go to state 134
    arith_expr                     shift and go to state 69
    incr_expr                      shift and go to state 71
    basic_expr                     shift and go to state 72

state 107

    (44) stmt_return -> RETURN expr . SEMICOLON

    SEMICOLON       shift and go to state 135


state 108

    (45) stmt_return -> RETURN SEMICOLON .

    RBRACE          reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    IF              reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    PRINT           reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    ID              reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    TIMES           reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    FOR             reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    RETURN          reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    INCREMENT       reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    INT             reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    VOID            reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    MINUS           reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    FNUM            reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    INUM            reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    ADDRESS         reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)
    ELSE            reduce using rule 45 (stmt_return -> RETURN SEMICOLON .)


state 109

    (58) incr_expr -> INCREMENT ID .

    SEMICOLON       reduce using rule 58 (incr_expr -> INCREMENT ID .)
    error           reduce using rule 58 (incr_expr -> INCREMENT ID .)
    RPAREN          reduce using rule 58 (incr_expr -> INCREMENT ID .)


state 110

    (59) arith_expr -> MINUS arith_expr .
    (61) arith_expr -> arith_expr . PLUS arith_expr
    (62) arith_expr -> arith_expr . MINUS arith_expr
    (63) arith_expr -> arith_expr . TIMES arith_expr
    (64) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 59 (arith_expr -> MINUS arith_expr .)
    MINUS           reduce using rule 59 (arith_expr -> MINUS arith_expr .)
    TIMES           reduce using rule 59 (arith_expr -> MINUS arith_expr .)
    DIV             reduce using rule 59 (arith_expr -> MINUS arith_expr .)
    EQ              reduce using rule 59 (arith_expr -> MINUS arith_expr .)
    NEQ             reduce using rule 59 (arith_expr -> MINUS arith_expr .)
    GT              reduce using rule 59 (arith_expr -> MINUS arith_expr .)
    LT              reduce using rule 59 (arith_expr -> MINUS arith_expr .)
    SEMICOLON       reduce using rule 59 (arith_expr -> MINUS arith_expr .)
    error           reduce using rule 59 (arith_expr -> MINUS arith_expr .)
    RPAREN          reduce using rule 59 (arith_expr -> MINUS arith_expr .)
    COMMA           reduce using rule 59 (arith_expr -> MINUS arith_expr .)
    RBRACKET        reduce using rule 59 (arith_expr -> MINUS arith_expr .)

  ! PLUS            [ shift and go to state 94 ]
  ! MINUS           [ shift and go to state 95 ]
  ! TIMES           [ shift and go to state 96 ]
  ! DIV             [ shift and go to state 97 ]


state 111

    (71) arith_expr -> ADDRESS ID .

    PLUS            reduce using rule 71 (arith_expr -> ADDRESS ID .)
    MINUS           reduce using rule 71 (arith_expr -> ADDRESS ID .)
    TIMES           reduce using rule 71 (arith_expr -> ADDRESS ID .)
    DIV             reduce using rule 71 (arith_expr -> ADDRESS ID .)
    EQ              reduce using rule 71 (arith_expr -> ADDRESS ID .)
    NEQ             reduce using rule 71 (arith_expr -> ADDRESS ID .)
    GT              reduce using rule 71 (arith_expr -> ADDRESS ID .)
    LT              reduce using rule 71 (arith_expr -> ADDRESS ID .)
    SEMICOLON       reduce using rule 71 (arith_expr -> ADDRESS ID .)
    error           reduce using rule 71 (arith_expr -> ADDRESS ID .)
    RPAREN          reduce using rule 71 (arith_expr -> ADDRESS ID .)
    COMMA           reduce using rule 71 (arith_expr -> ADDRESS ID .)
    RBRACKET        reduce using rule 71 (arith_expr -> ADDRESS ID .)


state 112

    (19) mstmt -> IF LPAREN expr . RPAREN mstmt ELSE mstmt
    (21) umstmt -> IF LPAREN expr . RPAREN genstmt
    (22) umstmt -> IF LPAREN expr . RPAREN mstmt ELSE umstmt

    RPAREN          shift and go to state 136


state 113

    (60) arith_expr -> LPAREN arith_expr RPAREN .

    PLUS            reduce using rule 60 (arith_expr -> LPAREN arith_expr RPAREN .)
    MINUS           reduce using rule 60 (arith_expr -> LPAREN arith_expr RPAREN .)
    TIMES           reduce using rule 60 (arith_expr -> LPAREN arith_expr RPAREN .)
    DIV             reduce using rule 60 (arith_expr -> LPAREN arith_expr RPAREN .)
    EQ              reduce using rule 60 (arith_expr -> LPAREN arith_expr RPAREN .)
    NEQ             reduce using rule 60 (arith_expr -> LPAREN arith_expr RPAREN .)
    GT              reduce using rule 60 (arith_expr -> LPAREN arith_expr RPAREN .)
    LT              reduce using rule 60 (arith_expr -> LPAREN arith_expr RPAREN .)
    SEMICOLON       reduce using rule 60 (arith_expr -> LPAREN arith_expr RPAREN .)
    error           reduce using rule 60 (arith_expr -> LPAREN arith_expr RPAREN .)
    RPAREN          reduce using rule 60 (arith_expr -> LPAREN arith_expr RPAREN .)
    COMMA           reduce using rule 60 (arith_expr -> LPAREN arith_expr RPAREN .)
    RBRACKET        reduce using rule 60 (arith_expr -> LPAREN arith_expr RPAREN .)


state 114

    (68) arith_expr -> TIMES ID .
    (70) arith_expr -> TIMES ID . LPAREN argument_list RPAREN
    (73) arith_expr -> TIMES ID . LBRACKET arith_expr RBRACKET

    RPAREN          reduce using rule 68 (arith_expr -> TIMES ID .)
    PLUS            reduce using rule 68 (arith_expr -> TIMES ID .)
    MINUS           reduce using rule 68 (arith_expr -> TIMES ID .)
    TIMES           reduce using rule 68 (arith_expr -> TIMES ID .)
    DIV             reduce using rule 68 (arith_expr -> TIMES ID .)
    EQ              reduce using rule 68 (arith_expr -> TIMES ID .)
    NEQ             reduce using rule 68 (arith_expr -> TIMES ID .)
    GT              reduce using rule 68 (arith_expr -> TIMES ID .)
    LT              reduce using rule 68 (arith_expr -> TIMES ID .)
    SEMICOLON       reduce using rule 68 (arith_expr -> TIMES ID .)
    error           reduce using rule 68 (arith_expr -> TIMES ID .)
    COMMA           reduce using rule 68 (arith_expr -> TIMES ID .)
    RBRACKET        reduce using rule 68 (arith_expr -> TIMES ID .)
    LPAREN          shift and go to state 130
    LBRACKET        shift and go to state 131


state 115

    (72) arith_expr -> ID LBRACKET . arith_expr RBRACKET
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    arith_expr                     shift and go to state 137

state 116

    (30) stmt -> PRINT LPAREN argument_list . RPAREN SEMICOLON
    (76) argument_list -> argument_list . COMMA argument

    RPAREN          shift and go to state 138
    COMMA           shift and go to state 139


state 117

    (75) argument_list -> argument .

    RPAREN          reduce using rule 75 (argument_list -> argument .)
    COMMA           reduce using rule 75 (argument_list -> argument .)


state 118

    (77) argument -> empty .

    RPAREN          reduce using rule 77 (argument -> empty .)
    COMMA           reduce using rule 77 (argument -> empty .)


state 119

    (78) argument -> arith_expr .
    (61) arith_expr -> arith_expr . PLUS arith_expr
    (62) arith_expr -> arith_expr . MINUS arith_expr
    (63) arith_expr -> arith_expr . TIMES arith_expr
    (64) arith_expr -> arith_expr . DIV arith_expr

    RPAREN          reduce using rule 78 (argument -> arith_expr .)
    COMMA           reduce using rule 78 (argument -> arith_expr .)
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    TIMES           shift and go to state 96
    DIV             shift and go to state 97


state 120

    (79) argument -> LITERAL .

    RPAREN          reduce using rule 79 (argument -> LITERAL .)
    COMMA           reduce using rule 79 (argument -> LITERAL .)


state 121

    (80) argument -> error .

    RPAREN          reduce using rule 80 (argument -> error .)
    COMMA           reduce using rule 80 (argument -> error .)


state 122

    (46) expr -> ID EQUAL expr .

    SEMICOLON       reduce using rule 46 (expr -> ID EQUAL expr .)
    error           reduce using rule 46 (expr -> ID EQUAL expr .)
    RPAREN          reduce using rule 46 (expr -> ID EQUAL expr .)


state 123

    (47) expr -> ID LBRACKET arith_expr . RBRACKET EQUAL expr
    (72) arith_expr -> ID LBRACKET arith_expr . RBRACKET
    (61) arith_expr -> arith_expr . PLUS arith_expr
    (62) arith_expr -> arith_expr . MINUS arith_expr
    (63) arith_expr -> arith_expr . TIMES arith_expr
    (64) arith_expr -> arith_expr . DIV arith_expr

    RBRACKET        shift and go to state 140
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    TIMES           shift and go to state 96
    DIV             shift and go to state 97


state 124

    (74) arith_expr -> ID LPAREN argument_list . RPAREN
    (76) argument_list -> argument_list . COMMA argument

    RPAREN          shift and go to state 141
    COMMA           shift and go to state 139


state 125

    (61) arith_expr -> arith_expr PLUS arith_expr .
    (61) arith_expr -> arith_expr . PLUS arith_expr
    (62) arith_expr -> arith_expr . MINUS arith_expr
    (63) arith_expr -> arith_expr . TIMES arith_expr
    (64) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 61 (arith_expr -> arith_expr PLUS arith_expr .)
    MINUS           reduce using rule 61 (arith_expr -> arith_expr PLUS arith_expr .)
    EQ              reduce using rule 61 (arith_expr -> arith_expr PLUS arith_expr .)
    NEQ             reduce using rule 61 (arith_expr -> arith_expr PLUS arith_expr .)
    GT              reduce using rule 61 (arith_expr -> arith_expr PLUS arith_expr .)
    LT              reduce using rule 61 (arith_expr -> arith_expr PLUS arith_expr .)
    SEMICOLON       reduce using rule 61 (arith_expr -> arith_expr PLUS arith_expr .)
    error           reduce using rule 61 (arith_expr -> arith_expr PLUS arith_expr .)
    RPAREN          reduce using rule 61 (arith_expr -> arith_expr PLUS arith_expr .)
    COMMA           reduce using rule 61 (arith_expr -> arith_expr PLUS arith_expr .)
    RBRACKET        reduce using rule 61 (arith_expr -> arith_expr PLUS arith_expr .)
    TIMES           shift and go to state 96
    DIV             shift and go to state 97

  ! TIMES           [ reduce using rule 61 (arith_expr -> arith_expr PLUS arith_expr .) ]
  ! DIV             [ reduce using rule 61 (arith_expr -> arith_expr PLUS arith_expr .) ]
  ! PLUS            [ shift and go to state 94 ]
  ! MINUS           [ shift and go to state 95 ]


state 126

    (62) arith_expr -> arith_expr MINUS arith_expr .
    (61) arith_expr -> arith_expr . PLUS arith_expr
    (62) arith_expr -> arith_expr . MINUS arith_expr
    (63) arith_expr -> arith_expr . TIMES arith_expr
    (64) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 62 (arith_expr -> arith_expr MINUS arith_expr .)
    MINUS           reduce using rule 62 (arith_expr -> arith_expr MINUS arith_expr .)
    EQ              reduce using rule 62 (arith_expr -> arith_expr MINUS arith_expr .)
    NEQ             reduce using rule 62 (arith_expr -> arith_expr MINUS arith_expr .)
    GT              reduce using rule 62 (arith_expr -> arith_expr MINUS arith_expr .)
    LT              reduce using rule 62 (arith_expr -> arith_expr MINUS arith_expr .)
    SEMICOLON       reduce using rule 62 (arith_expr -> arith_expr MINUS arith_expr .)
    error           reduce using rule 62 (arith_expr -> arith_expr MINUS arith_expr .)
    RPAREN          reduce using rule 62 (arith_expr -> arith_expr MINUS arith_expr .)
    COMMA           reduce using rule 62 (arith_expr -> arith_expr MINUS arith_expr .)
    RBRACKET        reduce using rule 62 (arith_expr -> arith_expr MINUS arith_expr .)
    TIMES           shift and go to state 96
    DIV             shift and go to state 97

  ! TIMES           [ reduce using rule 62 (arith_expr -> arith_expr MINUS arith_expr .) ]
  ! DIV             [ reduce using rule 62 (arith_expr -> arith_expr MINUS arith_expr .) ]
  ! PLUS            [ shift and go to state 94 ]
  ! MINUS           [ shift and go to state 95 ]


state 127

    (63) arith_expr -> arith_expr TIMES arith_expr .
    (61) arith_expr -> arith_expr . PLUS arith_expr
    (62) arith_expr -> arith_expr . MINUS arith_expr
    (63) arith_expr -> arith_expr . TIMES arith_expr
    (64) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 63 (arith_expr -> arith_expr TIMES arith_expr .)
    MINUS           reduce using rule 63 (arith_expr -> arith_expr TIMES arith_expr .)
    TIMES           reduce using rule 63 (arith_expr -> arith_expr TIMES arith_expr .)
    DIV             reduce using rule 63 (arith_expr -> arith_expr TIMES arith_expr .)
    EQ              reduce using rule 63 (arith_expr -> arith_expr TIMES arith_expr .)
    NEQ             reduce using rule 63 (arith_expr -> arith_expr TIMES arith_expr .)
    GT              reduce using rule 63 (arith_expr -> arith_expr TIMES arith_expr .)
    LT              reduce using rule 63 (arith_expr -> arith_expr TIMES arith_expr .)
    SEMICOLON       reduce using rule 63 (arith_expr -> arith_expr TIMES arith_expr .)
    error           reduce using rule 63 (arith_expr -> arith_expr TIMES arith_expr .)
    RPAREN          reduce using rule 63 (arith_expr -> arith_expr TIMES arith_expr .)
    COMMA           reduce using rule 63 (arith_expr -> arith_expr TIMES arith_expr .)
    RBRACKET        reduce using rule 63 (arith_expr -> arith_expr TIMES arith_expr .)

  ! PLUS            [ shift and go to state 94 ]
  ! MINUS           [ shift and go to state 95 ]
  ! TIMES           [ shift and go to state 96 ]
  ! DIV             [ shift and go to state 97 ]


state 128

    (64) arith_expr -> arith_expr DIV arith_expr .
    (61) arith_expr -> arith_expr . PLUS arith_expr
    (62) arith_expr -> arith_expr . MINUS arith_expr
    (63) arith_expr -> arith_expr . TIMES arith_expr
    (64) arith_expr -> arith_expr . DIV arith_expr

    PLUS            reduce using rule 64 (arith_expr -> arith_expr DIV arith_expr .)
    MINUS           reduce using rule 64 (arith_expr -> arith_expr DIV arith_expr .)
    TIMES           reduce using rule 64 (arith_expr -> arith_expr DIV arith_expr .)
    DIV             reduce using rule 64 (arith_expr -> arith_expr DIV arith_expr .)
    EQ              reduce using rule 64 (arith_expr -> arith_expr DIV arith_expr .)
    NEQ             reduce using rule 64 (arith_expr -> arith_expr DIV arith_expr .)
    GT              reduce using rule 64 (arith_expr -> arith_expr DIV arith_expr .)
    LT              reduce using rule 64 (arith_expr -> arith_expr DIV arith_expr .)
    SEMICOLON       reduce using rule 64 (arith_expr -> arith_expr DIV arith_expr .)
    error           reduce using rule 64 (arith_expr -> arith_expr DIV arith_expr .)
    RPAREN          reduce using rule 64 (arith_expr -> arith_expr DIV arith_expr .)
    COMMA           reduce using rule 64 (arith_expr -> arith_expr DIV arith_expr .)
    RBRACKET        reduce using rule 64 (arith_expr -> arith_expr DIV arith_expr .)

  ! PLUS            [ shift and go to state 94 ]
  ! MINUS           [ shift and go to state 95 ]
  ! TIMES           [ shift and go to state 96 ]
  ! DIV             [ shift and go to state 97 ]


state 129

    (48) expr -> TIMES ID EQUAL . expr
    (46) expr -> . ID EQUAL expr
    (47) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (48) expr -> . TIMES ID EQUAL expr
    (49) expr -> . incr_expr
    (50) expr -> . basic_expr
    (57) incr_expr -> . ID INCREMENT
    (58) incr_expr -> . INCREMENT ID
    (51) basic_expr -> . basic_expr compare arith_expr
    (52) basic_expr -> . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 68
    TIMES           shift and go to state 70
    INCREMENT       shift and go to state 76
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    ADDRESS         shift and go to state 80

    expr                           shift and go to state 142
    arith_expr                     shift and go to state 69
    incr_expr                      shift and go to state 71
    basic_expr                     shift and go to state 72

state 130

    (70) arith_expr -> TIMES ID LPAREN . argument_list RPAREN
    (75) argument_list -> . argument
    (76) argument_list -> . argument_list COMMA argument
    (77) argument -> . empty
    (78) argument -> . arith_expr
    (79) argument -> . LITERAL
    (80) argument -> . error
    (81) empty -> .
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    LITERAL         shift and go to state 120
    error           shift and go to state 121
    RPAREN          reduce using rule 81 (empty -> .)
    COMMA           reduce using rule 81 (empty -> .)
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    argument_list                  shift and go to state 143
    argument                       shift and go to state 117
    empty                          shift and go to state 118
    arith_expr                     shift and go to state 119

state 131

    (73) arith_expr -> TIMES ID LBRACKET . arith_expr RBRACKET
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    arith_expr                     shift and go to state 144

state 132

    (69) arith_expr -> TIMES LPAREN arith_expr . RPAREN
    (61) arith_expr -> arith_expr . PLUS arith_expr
    (62) arith_expr -> arith_expr . MINUS arith_expr
    (63) arith_expr -> arith_expr . TIMES arith_expr
    (64) arith_expr -> arith_expr . DIV arith_expr

    RPAREN          shift and go to state 145
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    TIMES           shift and go to state 96
    DIV             shift and go to state 97


state 133

    (51) basic_expr -> basic_expr compare arith_expr .
    (61) arith_expr -> arith_expr . PLUS arith_expr
    (62) arith_expr -> arith_expr . MINUS arith_expr
    (63) arith_expr -> arith_expr . TIMES arith_expr
    (64) arith_expr -> arith_expr . DIV arith_expr

    EQ              reduce using rule 51 (basic_expr -> basic_expr compare arith_expr .)
    NEQ             reduce using rule 51 (basic_expr -> basic_expr compare arith_expr .)
    GT              reduce using rule 51 (basic_expr -> basic_expr compare arith_expr .)
    LT              reduce using rule 51 (basic_expr -> basic_expr compare arith_expr .)
    SEMICOLON       reduce using rule 51 (basic_expr -> basic_expr compare arith_expr .)
    error           reduce using rule 51 (basic_expr -> basic_expr compare arith_expr .)
    RPAREN          reduce using rule 51 (basic_expr -> basic_expr compare arith_expr .)
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    TIMES           shift and go to state 96
    DIV             shift and go to state 97


state 134

    (43) stmt_forloop -> FOR LPAREN expr . SEMICOLON expr SEMICOLON expr RPAREN stmt

    SEMICOLON       shift and go to state 146


state 135

    (44) stmt_return -> RETURN expr SEMICOLON .

    RBRACE          reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    IF              reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    PRINT           reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    ID              reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    TIMES           reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    INCREMENT       reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    INT             reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    VOID            reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    MINUS           reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    FNUM            reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    INUM            reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    ADDRESS         reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 44 (stmt_return -> RETURN expr SEMICOLON .)


state 136

    (19) mstmt -> IF LPAREN expr RPAREN . mstmt ELSE mstmt
    (21) umstmt -> IF LPAREN expr RPAREN . genstmt
    (22) umstmt -> IF LPAREN expr RPAREN . mstmt ELSE umstmt
    (19) mstmt -> . IF LPAREN expr RPAREN mstmt ELSE mstmt
    (20) mstmt -> . stmt
    (17) genstmt -> . mstmt
    (18) genstmt -> . umstmt
    (23) stmt -> . expr SEMICOLON
    (24) stmt -> . declaration SEMICOLON
    (25) stmt -> . stmt_block
    (26) stmt -> . stmt_forloop
    (27) stmt -> . stmt_return
    (28) stmt -> . SEMICOLON
    (29) stmt -> . expr error
    (30) stmt -> . PRINT LPAREN argument_list RPAREN SEMICOLON
    (21) umstmt -> . IF LPAREN expr RPAREN genstmt
    (22) umstmt -> . IF LPAREN expr RPAREN mstmt ELSE umstmt
    (46) expr -> . ID EQUAL expr
    (47) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (48) expr -> . TIMES ID EQUAL expr
    (49) expr -> . incr_expr
    (50) expr -> . basic_expr
    (31) declaration -> . declaration COMMA idbracket
    (32) declaration -> . declaration COMMA TIMES idbracket
    (33) declaration -> . type idbracket
    (34) declaration -> . type TIMES idbracket
    (40) stmt_block -> . LBRACE stmt_list RBRACE
    (43) stmt_forloop -> . FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (44) stmt_return -> . RETURN expr SEMICOLON
    (45) stmt_return -> . RETURN SEMICOLON
    (57) incr_expr -> . ID INCREMENT
    (58) incr_expr -> . INCREMENT ID
    (51) basic_expr -> . basic_expr compare arith_expr
    (52) basic_expr -> . arith_expr
    (37) type -> . INT
    (38) type -> . FLOAT
    (39) type -> . VOID
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    IF              shift and go to state 58
    SEMICOLON       shift and go to state 62
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    TIMES           shift and go to state 70
    LBRACE          shift and go to state 39
    FOR             shift and go to state 74
    RETURN          shift and go to state 75
    INCREMENT       shift and go to state 76
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    ADDRESS         shift and go to state 80

    expr                           shift and go to state 60
    mstmt                          shift and go to state 147
    genstmt                        shift and go to state 148
    umstmt                         shift and go to state 57
    stmt                           shift and go to state 61
    declaration                    shift and go to state 63
    stmt_block                     shift and go to state 64
    stmt_forloop                   shift and go to state 65
    stmt_return                    shift and go to state 66
    arith_expr                     shift and go to state 69
    incr_expr                      shift and go to state 71
    basic_expr                     shift and go to state 72
    type                           shift and go to state 73

state 137

    (72) arith_expr -> ID LBRACKET arith_expr . RBRACKET
    (61) arith_expr -> arith_expr . PLUS arith_expr
    (62) arith_expr -> arith_expr . MINUS arith_expr
    (63) arith_expr -> arith_expr . TIMES arith_expr
    (64) arith_expr -> arith_expr . DIV arith_expr

    RBRACKET        shift and go to state 149
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    TIMES           shift and go to state 96
    DIV             shift and go to state 97


state 138

    (30) stmt -> PRINT LPAREN argument_list RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 150


state 139

    (76) argument_list -> argument_list COMMA . argument
    (77) argument -> . empty
    (78) argument -> . arith_expr
    (79) argument -> . LITERAL
    (80) argument -> . error
    (81) empty -> .
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    LITERAL         shift and go to state 120
    error           shift and go to state 121
    RPAREN          reduce using rule 81 (empty -> .)
    COMMA           reduce using rule 81 (empty -> .)
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    ID              shift and go to state 85
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    TIMES           shift and go to state 84
    ADDRESS         shift and go to state 80

    argument                       shift and go to state 151
    empty                          shift and go to state 118
    arith_expr                     shift and go to state 119

state 140

    (47) expr -> ID LBRACKET arith_expr RBRACKET . EQUAL expr
    (72) arith_expr -> ID LBRACKET arith_expr RBRACKET .

    EQUAL           shift and go to state 152
    PLUS            reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    MINUS           reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    TIMES           reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    DIV             reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    EQ              reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    NEQ             reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    GT              reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    LT              reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    SEMICOLON       reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    error           reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    RPAREN          reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)


state 141

    (74) arith_expr -> ID LPAREN argument_list RPAREN .

    PLUS            reduce using rule 74 (arith_expr -> ID LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 74 (arith_expr -> ID LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 74 (arith_expr -> ID LPAREN argument_list RPAREN .)
    DIV             reduce using rule 74 (arith_expr -> ID LPAREN argument_list RPAREN .)
    EQ              reduce using rule 74 (arith_expr -> ID LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 74 (arith_expr -> ID LPAREN argument_list RPAREN .)
    GT              reduce using rule 74 (arith_expr -> ID LPAREN argument_list RPAREN .)
    LT              reduce using rule 74 (arith_expr -> ID LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 74 (arith_expr -> ID LPAREN argument_list RPAREN .)
    error           reduce using rule 74 (arith_expr -> ID LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 74 (arith_expr -> ID LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 74 (arith_expr -> ID LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 74 (arith_expr -> ID LPAREN argument_list RPAREN .)


state 142

    (48) expr -> TIMES ID EQUAL expr .

    SEMICOLON       reduce using rule 48 (expr -> TIMES ID EQUAL expr .)
    error           reduce using rule 48 (expr -> TIMES ID EQUAL expr .)
    RPAREN          reduce using rule 48 (expr -> TIMES ID EQUAL expr .)


state 143

    (70) arith_expr -> TIMES ID LPAREN argument_list . RPAREN
    (76) argument_list -> argument_list . COMMA argument

    RPAREN          shift and go to state 153
    COMMA           shift and go to state 139


state 144

    (73) arith_expr -> TIMES ID LBRACKET arith_expr . RBRACKET
    (61) arith_expr -> arith_expr . PLUS arith_expr
    (62) arith_expr -> arith_expr . MINUS arith_expr
    (63) arith_expr -> arith_expr . TIMES arith_expr
    (64) arith_expr -> arith_expr . DIV arith_expr

    RBRACKET        shift and go to state 154
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95
    TIMES           shift and go to state 96
    DIV             shift and go to state 97


state 145

    (69) arith_expr -> TIMES LPAREN arith_expr RPAREN .

    PLUS            reduce using rule 69 (arith_expr -> TIMES LPAREN arith_expr RPAREN .)
    MINUS           reduce using rule 69 (arith_expr -> TIMES LPAREN arith_expr RPAREN .)
    TIMES           reduce using rule 69 (arith_expr -> TIMES LPAREN arith_expr RPAREN .)
    DIV             reduce using rule 69 (arith_expr -> TIMES LPAREN arith_expr RPAREN .)
    EQ              reduce using rule 69 (arith_expr -> TIMES LPAREN arith_expr RPAREN .)
    NEQ             reduce using rule 69 (arith_expr -> TIMES LPAREN arith_expr RPAREN .)
    GT              reduce using rule 69 (arith_expr -> TIMES LPAREN arith_expr RPAREN .)
    LT              reduce using rule 69 (arith_expr -> TIMES LPAREN arith_expr RPAREN .)
    SEMICOLON       reduce using rule 69 (arith_expr -> TIMES LPAREN arith_expr RPAREN .)
    error           reduce using rule 69 (arith_expr -> TIMES LPAREN arith_expr RPAREN .)
    RPAREN          reduce using rule 69 (arith_expr -> TIMES LPAREN arith_expr RPAREN .)
    COMMA           reduce using rule 69 (arith_expr -> TIMES LPAREN arith_expr RPAREN .)
    RBRACKET        reduce using rule 69 (arith_expr -> TIMES LPAREN arith_expr RPAREN .)


state 146

    (43) stmt_forloop -> FOR LPAREN expr SEMICOLON . expr SEMICOLON expr RPAREN stmt
    (46) expr -> . ID EQUAL expr
    (47) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (48) expr -> . TIMES ID EQUAL expr
    (49) expr -> . incr_expr
    (50) expr -> . basic_expr
    (57) incr_expr -> . ID INCREMENT
    (58) incr_expr -> . INCREMENT ID
    (51) basic_expr -> . basic_expr compare arith_expr
    (52) basic_expr -> . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 68
    TIMES           shift and go to state 70
    INCREMENT       shift and go to state 76
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    ADDRESS         shift and go to state 80

    expr                           shift and go to state 155
    arith_expr                     shift and go to state 69
    incr_expr                      shift and go to state 71
    basic_expr                     shift and go to state 72

state 147

    (19) mstmt -> IF LPAREN expr RPAREN mstmt . ELSE mstmt
    (22) umstmt -> IF LPAREN expr RPAREN mstmt . ELSE umstmt
    (17) genstmt -> mstmt .

    ELSE            shift and go to state 156
    RBRACE          reduce using rule 17 (genstmt -> mstmt .)
    IF              reduce using rule 17 (genstmt -> mstmt .)
    SEMICOLON       reduce using rule 17 (genstmt -> mstmt .)
    PRINT           reduce using rule 17 (genstmt -> mstmt .)
    ID              reduce using rule 17 (genstmt -> mstmt .)
    TIMES           reduce using rule 17 (genstmt -> mstmt .)
    LBRACE          reduce using rule 17 (genstmt -> mstmt .)
    FOR             reduce using rule 17 (genstmt -> mstmt .)
    RETURN          reduce using rule 17 (genstmt -> mstmt .)
    INCREMENT       reduce using rule 17 (genstmt -> mstmt .)
    INT             reduce using rule 17 (genstmt -> mstmt .)
    FLOAT           reduce using rule 17 (genstmt -> mstmt .)
    VOID            reduce using rule 17 (genstmt -> mstmt .)
    MINUS           reduce using rule 17 (genstmt -> mstmt .)
    LPAREN          reduce using rule 17 (genstmt -> mstmt .)
    FNUM            reduce using rule 17 (genstmt -> mstmt .)
    INUM            reduce using rule 17 (genstmt -> mstmt .)
    ADDRESS         reduce using rule 17 (genstmt -> mstmt .)


state 148

    (21) umstmt -> IF LPAREN expr RPAREN genstmt .

    RBRACE          reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    IF              reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    SEMICOLON       reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    PRINT           reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    ID              reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    TIMES           reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    LBRACE          reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    FOR             reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    RETURN          reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    INCREMENT       reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    INT             reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    FLOAT           reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    VOID            reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    MINUS           reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    LPAREN          reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    FNUM            reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    INUM            reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)
    ADDRESS         reduce using rule 21 (umstmt -> IF LPAREN expr RPAREN genstmt .)


state 149

    (72) arith_expr -> ID LBRACKET arith_expr RBRACKET .

    RPAREN          reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    PLUS            reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    MINUS           reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    TIMES           reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    DIV             reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    EQ              reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    NEQ             reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    GT              reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    LT              reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    SEMICOLON       reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    error           reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    COMMA           reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)
    RBRACKET        reduce using rule 72 (arith_expr -> ID LBRACKET arith_expr RBRACKET .)


state 150

    (30) stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .

    RBRACE          reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    IF              reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    PRINT           reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    ID              reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    TIMES           reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    LBRACE          reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    FOR             reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    RETURN          reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    INT             reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    FLOAT           reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    VOID            reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    MINUS           reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    LPAREN          reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    FNUM            reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    INUM            reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    ADDRESS         reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)
    ELSE            reduce using rule 30 (stmt -> PRINT LPAREN argument_list RPAREN SEMICOLON .)


state 151

    (76) argument_list -> argument_list COMMA argument .

    RPAREN          reduce using rule 76 (argument_list -> argument_list COMMA argument .)
    COMMA           reduce using rule 76 (argument_list -> argument_list COMMA argument .)


state 152

    (47) expr -> ID LBRACKET arith_expr RBRACKET EQUAL . expr
    (46) expr -> . ID EQUAL expr
    (47) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (48) expr -> . TIMES ID EQUAL expr
    (49) expr -> . incr_expr
    (50) expr -> . basic_expr
    (57) incr_expr -> . ID INCREMENT
    (58) incr_expr -> . INCREMENT ID
    (51) basic_expr -> . basic_expr compare arith_expr
    (52) basic_expr -> . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 68
    TIMES           shift and go to state 70
    INCREMENT       shift and go to state 76
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    ADDRESS         shift and go to state 80

    arith_expr                     shift and go to state 69
    expr                           shift and go to state 157
    incr_expr                      shift and go to state 71
    basic_expr                     shift and go to state 72

state 153

    (70) arith_expr -> TIMES ID LPAREN argument_list RPAREN .

    PLUS            reduce using rule 70 (arith_expr -> TIMES ID LPAREN argument_list RPAREN .)
    MINUS           reduce using rule 70 (arith_expr -> TIMES ID LPAREN argument_list RPAREN .)
    TIMES           reduce using rule 70 (arith_expr -> TIMES ID LPAREN argument_list RPAREN .)
    DIV             reduce using rule 70 (arith_expr -> TIMES ID LPAREN argument_list RPAREN .)
    EQ              reduce using rule 70 (arith_expr -> TIMES ID LPAREN argument_list RPAREN .)
    NEQ             reduce using rule 70 (arith_expr -> TIMES ID LPAREN argument_list RPAREN .)
    GT              reduce using rule 70 (arith_expr -> TIMES ID LPAREN argument_list RPAREN .)
    LT              reduce using rule 70 (arith_expr -> TIMES ID LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 70 (arith_expr -> TIMES ID LPAREN argument_list RPAREN .)
    error           reduce using rule 70 (arith_expr -> TIMES ID LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 70 (arith_expr -> TIMES ID LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 70 (arith_expr -> TIMES ID LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 70 (arith_expr -> TIMES ID LPAREN argument_list RPAREN .)


state 154

    (73) arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .

    PLUS            reduce using rule 73 (arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .)
    MINUS           reduce using rule 73 (arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .)
    TIMES           reduce using rule 73 (arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .)
    DIV             reduce using rule 73 (arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .)
    EQ              reduce using rule 73 (arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .)
    NEQ             reduce using rule 73 (arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .)
    GT              reduce using rule 73 (arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .)
    LT              reduce using rule 73 (arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .)
    SEMICOLON       reduce using rule 73 (arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .)
    error           reduce using rule 73 (arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .)
    RPAREN          reduce using rule 73 (arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .)
    COMMA           reduce using rule 73 (arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .)
    RBRACKET        reduce using rule 73 (arith_expr -> TIMES ID LBRACKET arith_expr RBRACKET .)


state 155

    (43) stmt_forloop -> FOR LPAREN expr SEMICOLON expr . SEMICOLON expr RPAREN stmt

    SEMICOLON       shift and go to state 158


state 156

    (19) mstmt -> IF LPAREN expr RPAREN mstmt ELSE . mstmt
    (22) umstmt -> IF LPAREN expr RPAREN mstmt ELSE . umstmt
    (19) mstmt -> . IF LPAREN expr RPAREN mstmt ELSE mstmt
    (20) mstmt -> . stmt
    (21) umstmt -> . IF LPAREN expr RPAREN genstmt
    (22) umstmt -> . IF LPAREN expr RPAREN mstmt ELSE umstmt
    (23) stmt -> . expr SEMICOLON
    (24) stmt -> . declaration SEMICOLON
    (25) stmt -> . stmt_block
    (26) stmt -> . stmt_forloop
    (27) stmt -> . stmt_return
    (28) stmt -> . SEMICOLON
    (29) stmt -> . expr error
    (30) stmt -> . PRINT LPAREN argument_list RPAREN SEMICOLON
    (46) expr -> . ID EQUAL expr
    (47) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (48) expr -> . TIMES ID EQUAL expr
    (49) expr -> . incr_expr
    (50) expr -> . basic_expr
    (31) declaration -> . declaration COMMA idbracket
    (32) declaration -> . declaration COMMA TIMES idbracket
    (33) declaration -> . type idbracket
    (34) declaration -> . type TIMES idbracket
    (40) stmt_block -> . LBRACE stmt_list RBRACE
    (43) stmt_forloop -> . FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (44) stmt_return -> . RETURN expr SEMICOLON
    (45) stmt_return -> . RETURN SEMICOLON
    (57) incr_expr -> . ID INCREMENT
    (58) incr_expr -> . INCREMENT ID
    (51) basic_expr -> . basic_expr compare arith_expr
    (52) basic_expr -> . arith_expr
    (37) type -> . INT
    (38) type -> . FLOAT
    (39) type -> . VOID
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    IF              shift and go to state 58
    SEMICOLON       shift and go to state 62
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    TIMES           shift and go to state 70
    LBRACE          shift and go to state 39
    FOR             shift and go to state 74
    RETURN          shift and go to state 75
    INCREMENT       shift and go to state 76
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    ADDRESS         shift and go to state 80

    expr                           shift and go to state 60
    mstmt                          shift and go to state 159
    umstmt                         shift and go to state 160
    stmt                           shift and go to state 61
    declaration                    shift and go to state 63
    stmt_block                     shift and go to state 64
    stmt_forloop                   shift and go to state 65
    stmt_return                    shift and go to state 66
    arith_expr                     shift and go to state 69
    incr_expr                      shift and go to state 71
    basic_expr                     shift and go to state 72
    type                           shift and go to state 73

state 157

    (47) expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr .

    SEMICOLON       reduce using rule 47 (expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr .)
    error           reduce using rule 47 (expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr .)
    RPAREN          reduce using rule 47 (expr -> ID LBRACKET arith_expr RBRACKET EQUAL expr .)


state 158

    (43) stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON . expr RPAREN stmt
    (46) expr -> . ID EQUAL expr
    (47) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (48) expr -> . TIMES ID EQUAL expr
    (49) expr -> . incr_expr
    (50) expr -> . basic_expr
    (57) incr_expr -> . ID INCREMENT
    (58) incr_expr -> . INCREMENT ID
    (51) basic_expr -> . basic_expr compare arith_expr
    (52) basic_expr -> . arith_expr
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    ID              shift and go to state 68
    TIMES           shift and go to state 70
    INCREMENT       shift and go to state 76
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    ADDRESS         shift and go to state 80

    expr                           shift and go to state 161
    arith_expr                     shift and go to state 69
    incr_expr                      shift and go to state 71
    basic_expr                     shift and go to state 72

state 159

    (19) mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .

    RBRACE          reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    IF              reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    SEMICOLON       reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    PRINT           reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    ID              reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    TIMES           reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    LBRACE          reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    FOR             reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    RETURN          reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    INCREMENT       reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    INT             reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    FLOAT           reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    VOID            reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    MINUS           reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    LPAREN          reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    FNUM            reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    INUM            reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    ADDRESS         reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)
    ELSE            reduce using rule 19 (mstmt -> IF LPAREN expr RPAREN mstmt ELSE mstmt .)


state 160

    (22) umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .

    RBRACE          reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    IF              reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    SEMICOLON       reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    PRINT           reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    ID              reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    TIMES           reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    LBRACE          reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    FOR             reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    RETURN          reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    INCREMENT       reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    INT             reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    FLOAT           reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    VOID            reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    MINUS           reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    LPAREN          reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    FNUM            reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    INUM            reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)
    ADDRESS         reduce using rule 22 (umstmt -> IF LPAREN expr RPAREN mstmt ELSE umstmt .)


state 161

    (43) stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr . RPAREN stmt

    RPAREN          shift and go to state 162


state 162

    (43) stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN . stmt
    (23) stmt -> . expr SEMICOLON
    (24) stmt -> . declaration SEMICOLON
    (25) stmt -> . stmt_block
    (26) stmt -> . stmt_forloop
    (27) stmt -> . stmt_return
    (28) stmt -> . SEMICOLON
    (29) stmt -> . expr error
    (30) stmt -> . PRINT LPAREN argument_list RPAREN SEMICOLON
    (46) expr -> . ID EQUAL expr
    (47) expr -> . ID LBRACKET arith_expr RBRACKET EQUAL expr
    (48) expr -> . TIMES ID EQUAL expr
    (49) expr -> . incr_expr
    (50) expr -> . basic_expr
    (31) declaration -> . declaration COMMA idbracket
    (32) declaration -> . declaration COMMA TIMES idbracket
    (33) declaration -> . type idbracket
    (34) declaration -> . type TIMES idbracket
    (40) stmt_block -> . LBRACE stmt_list RBRACE
    (43) stmt_forloop -> . FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    (44) stmt_return -> . RETURN expr SEMICOLON
    (45) stmt_return -> . RETURN SEMICOLON
    (57) incr_expr -> . ID INCREMENT
    (58) incr_expr -> . INCREMENT ID
    (51) basic_expr -> . basic_expr compare arith_expr
    (52) basic_expr -> . arith_expr
    (37) type -> . INT
    (38) type -> . FLOAT
    (39) type -> . VOID
    (59) arith_expr -> . MINUS arith_expr
    (60) arith_expr -> . LPAREN arith_expr RPAREN
    (61) arith_expr -> . arith_expr PLUS arith_expr
    (62) arith_expr -> . arith_expr MINUS arith_expr
    (63) arith_expr -> . arith_expr TIMES arith_expr
    (64) arith_expr -> . arith_expr DIV arith_expr
    (65) arith_expr -> . ID
    (66) arith_expr -> . FNUM
    (67) arith_expr -> . INUM
    (68) arith_expr -> . TIMES ID
    (69) arith_expr -> . TIMES LPAREN arith_expr RPAREN
    (70) arith_expr -> . TIMES ID LPAREN argument_list RPAREN
    (71) arith_expr -> . ADDRESS ID
    (72) arith_expr -> . ID LBRACKET arith_expr RBRACKET
    (73) arith_expr -> . TIMES ID LBRACKET arith_expr RBRACKET
    (74) arith_expr -> . ID LPAREN argument_list RPAREN

    SEMICOLON       shift and go to state 62
    PRINT           shift and go to state 67
    ID              shift and go to state 68
    TIMES           shift and go to state 70
    LBRACE          shift and go to state 39
    FOR             shift and go to state 74
    RETURN          shift and go to state 75
    INCREMENT       shift and go to state 76
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    VOID            shift and go to state 9
    MINUS           shift and go to state 77
    LPAREN          shift and go to state 59
    FNUM            shift and go to state 78
    INUM            shift and go to state 79
    ADDRESS         shift and go to state 80

    expr                           shift and go to state 60
    stmt                           shift and go to state 163
    declaration                    shift and go to state 63
    stmt_block                     shift and go to state 64
    stmt_forloop                   shift and go to state 65
    stmt_return                    shift and go to state 66
    arith_expr                     shift and go to state 69
    incr_expr                      shift and go to state 71
    basic_expr                     shift and go to state 72
    type                           shift and go to state 73

state 163

    (43) stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .

    RBRACE          reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    IF              reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    SEMICOLON       reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    PRINT           reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    ID              reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    TIMES           reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    LBRACE          reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    FOR             reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    RETURN          reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    INCREMENT       reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    INT             reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    FLOAT           reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    VOID            reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    MINUS           reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    LPAREN          reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    FNUM            reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    INUM            reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    ADDRESS         reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)
    ELSE            reduce using rule 43 (stmt_forloop -> FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt .)

